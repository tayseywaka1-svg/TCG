<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Monster Arena — フル版（デッキ編集・CPU対戦）</title>
<style>
:root{
  --bg:#071025; --panel:#0f1724; --muted:#94a3b8; --card:#f8fafc; --accent:#ef4444;
  --slot:#0b1a2b;
}
*{box-sizing:border-box;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif}
body{margin:0;background:linear-gradient(180deg,#03101a,#071025);color:#e6eef8}
header{padding:14px 18px;border-bottom:1px solid rgba(255,255,255,0.04);display:flex;align-items:center;gap:12px}
h1{margin:0;font-size:18px}
.container{padding:12px;display:grid;grid-template-columns:1fr;gap:12px;max-width:1200px;margin:0 auto}
.panel{background:var(--panel);padding:12px;border-radius:10px;box-shadow:0 8px 22px rgba(0,0,0,0.6)}
.row{display:flex;gap:12px;align-items:center}
.btn{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);border:1px solid rgba(255,255,255,0.04);padding:8px 10px;border-radius:8px;color:#e6eef8;cursor:pointer}
.small{font-size:13px;padding:6px 8px}
.menu{display:flex;gap:8px}
.grid{display:grid;grid-template-columns:1fr 360px;gap:12px}
.leftCol{min-height:400px}
.cardCompact{background:var(--card);color:#06101a;padding:8px;border-radius:8px;margin:6px 0;border:1px solid rgba(0,0,0,0.06)}
.cardList{max-height:420px;overflow:auto;padding-right:6px}
.deckView{max-height:420px;overflow:auto;padding-right:6px}
.smallMuted{color:var(--muted);font-size:13px}
.zone{background:linear-gradient(180deg,#071829,#071829);padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
.rowWrap{display:flex;flex-wrap:wrap;gap:8px}
.hand{display:flex;gap:8px;flex-wrap:wrap}
.cardUI{background:var(--card);color:#06101a;padding:8px;border-radius:8px;width:120px;box-shadow:0 6px 14px rgba(0,0,0,0.5);border:1px solid rgba(0,0,0,0.06)}
.battleRow{display:flex;gap:10px;justify-content:center}
.battleSlot{width:150px;height:110px;border-radius:8px;background:linear-gradient(180deg,var(--slot),#071225);display:flex;align-items:center;justify-content:center;position:relative;border:1px dashed rgba(255,255,255,0.03)}
.slotCard{background:#fff;color:#000;padding:6px;border-radius:6px;width:120px}
.log{height:300px;overflow:auto;background:linear-gradient(180deg,#04121a,#021018);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03)}
.controls{display:flex;gap:8px;align-items:center}
.footerNote{font-size:13px;color:var(--muted)}
.note{font-size:13px;color:var(--muted);margin-top:6px}
.fieldCard{background:#fff;padding:6px;border-radius:6px;color:#000}
.badge{background:#0ea5a4;padding:4px 6px;border-radius:6px;font-weight:700;color:#022}
.targetable{outline:3px solid rgba(255,200,0,0.2)}
@media(max-width:1000px){.grid{grid-template-columns:1fr}}
</style>
</head>
<body>
<header>
  <h1>Monster Arena — フル版</h1>
  <div style="margin-left:auto" class="smallMuted">ユニオンアリーナ風ルール（名称差替版）</div>
</header>

<div class="container">
  <!-- Main Menu / Views -->
  <div id="viewMenu" class="panel">
    <div class="row" style="justify-content:space-between;align-items:center">
      <div>
        <div style="font-weight:800">メインメニュー</div>
        <div class="smallMuted">デッキ編集 → 作成・保存 → CPU対戦ができます</div>
      </div>
      <div class="menu">
        <button class="btn small" onclick="showView('deckEditor')">デッキ編集</button>
        <button class="btn small" onclick="showView('cpuMatch')">CPU対戦</button>
        <button class="btn small" onclick="showView('ruleView')">ルール説明</button>
      </div>
    </div>
    <div style="margin-top:12px" class="row">
      <div style="flex:1">
        <div class="smallMuted">保存デッキ</div>
        <div id="savedDecksList" class="rowWrap" style="margin-top:8px"></div>
      </div>
      <div style="width:260px">
        <div class="smallMuted">クイック操作</div>
        <div style="margin-top:8px" class="row">
          <button class="btn small" onclick="quickSaveDefault()">現在のデッキをクイック保存</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Deck Editor -->
  <div id="viewDeckEditor" class="panel" style="display:none">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <div style="font-weight:800">デッキ編集</div>
        <div class="smallMuted">カードを選んでデッキ（50枚）を作成、保存できます。 同一カードは最大4枚。</div>
      </div>
      <div class="controls">
        <input id="deckNameInput" placeholder="デッキ名を入力" class="small" />
        <button class="btn small" onclick="saveDeck()">保存</button>
        <button class="btn small" onclick="clearDeck()">クリア</button>
        <button class="btn small" onclick="showView('viewMenu')">戻る</button>
      </div>
    </div>

    <div class="grid" style="margin-top:12px">
      <div class="leftCol">
        <div class="zone panel">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div style="font-weight:700">全カード（クリックで追加）</div>
            <div class="smallMuted">合計カード種類: <span id="cardPoolCount"></span></div>
          </div>
          <div class="cardList" id="allCardsArea" style="margin-top:8px"></div>
        </div>
      </div>

      <div>
        <div class="zone panel">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div style="font-weight:700">現在のデッキ</div>
            <div class="smallMuted">枚数: <span id="currentDeckCount">0</span>/50</div>
          </div>
          <div class="deckView" id="deckListArea" style="margin-top:8px"></div>
          <div style="margin-top:8px" class="note">カードの右の「−」でデッキから削除</div>
        </div>
        <div style="margin-top:8px" class="smallMuted">保存済デッキ管理</div>
        <div id="savedDecks" style="margin-top:6px" class="rowWrap"></div>
      </div>
    </div>
  </div>

  <!-- CPU Match -->
  <div id="viewCpuMatch" class="panel" style="display:none">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div>
        <div style="font-weight:800">CPU対戦</div>
        <div class="smallMuted">自分の保存デッキを選択して対戦開始してください</div>
      </div>
      <div class="controls">
        <select id="deckSelect" class="small"></select>
        <label class="smallMuted" style="margin-left:8px">先攻</label>
        <select id="whoGoesFirst" class="small">
          <option value="player">あなた</option>
          <option value="cpu">CPU</option>
        </select>
        <button class="btn small" onclick="startMatch()">対戦開始</button>
        <button class="btn small" onclick="showView('viewMenu')">戻る</button>
      </div>
    </div>

    <div style="margin-top:12px;display:flex;gap:12px">
      <div style="flex:1">
        <div class="zone panel">
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div style="font-weight:700">フィールド</div>
            <div class="smallMuted">ターン: <span id="uiTurn">0</span></div>
          </div>

          <!-- CPU area -->
          <div style="margin-top:10px">
            <div class="smallMuted">CPU — シールド: <span id="cpuShieldUI">7</span> | 山札: <span id="cpuDeckUI">50</span> | 墓地: <span id="cpuGraveUI">0</span> | マナ: <span id="cpuManaUI">0/0</span></div>
            <div style="margin-top:8px" class="battleRow" id="cpuBattleRow"></div>
            <div style="margin-top:6px" class="smallMuted">フィールド: <span id="cpuFieldUI">なし</span></div>
          </div>

          <hr style="margin:8px 0;border-color:rgba(255,255,255,0.03)"/>

          <!-- Player area -->
          <div>
            <div class="smallMuted">あなた — シールド: <span id="playerShieldUI">7</span> | 山札: <span id="playerDeckUI">50</span> | 墓地: <span id="playerGraveUI">0</span> | マナ: <span id="playerManaUI">0/0</span></div>
            <div style="margin-top:8px" class="battleRow" id="playerBattleRow"></div>
            <div style="margin-top:6px" class="smallMuted">フィールド: <span id="playerFieldUI">なし</span></div>
          </div>

          <!-- hand -->
          <div style="margin-top:10px">
            <div class="smallMuted">手札（クリックで使用）</div>
            <div class="hand" id="playerHandUI" style="margin-top:8px"></div>
          </div>

          <div style="margin-top:8px" class="controls">
            <button class="btn small" id="endTurnBtnMatch" onclick="endTurn()" disabled>ターン終了</button>
            <button class="btn small" onclick="forfeitMatch()">降参</button>
            <button class="btn small" onclick="shufflePlayerDeck()">デッキをシャッフル</button>
          </div>
        </div>
      </div>

      <div style="width:360px">
        <div class="zone panel">
          <div style="font-weight:700">行動ログ</div>
          <div class="log" id="matchLog"></div>
          <div style="margin-top:8px" class="smallMuted">プレイ履歴（リスト形式）</div>
          <div id="historyList" style="max-height:150px;overflow:auto;margin-top:6px"></div>
        </div>

        <div style="margin-top:12px" class="zone panel">
          <div style="font-weight:700">対戦情報</div>
          <div class="smallMuted" style="margin-top:8px">現在のモード: <span id="infoMode">待機</span></div>
          <div class="smallMuted">CPU強さ: 中程度</div>
          <div style="margin-top:8px" class="footerNote">注：カード効果は主要部分を実装。複雑なルールは省略または簡略化しています。</div>
        </div>
      </div>
    </div>
  </div>

  <!-- Rules View -->
  <div id="viewRule" class="panel" style="display:none">
    <div style="font-weight:800">ルール説明（簡略）</div>
    <div class="note">
      - デッキ50枚、同一カード4枚まで。<br/>
      - シールド（ライフ）は7枚。シールドが0かつ相手バトルゾーンが空の時にダイレクトアタックで即時勝利。<br/>
      - マナはターン開始時に全回復。先攻ターン1=1マナ、後攻ターン1=2マナ、ターン2=2、ターン3以降=3（最大3）。<br/>
      - カードは「モンスター」「魔法」「フィールド」。モンスターはバトルゾーンに出し、攻撃可能。魔法は使い切り。フィールドは場に1枚だけ置ける。<br/>
      - 多くのカード効果は簡略化して実装されています。詳細な挙動変更は調整可能です。
    </div>
    <div style="margin-top:8px">
      <button class="btn small" onclick="showView('viewMenu')">戻る</button>
    </div>
  </div>
</div>

<script>
/* ======= カードプール（あなたが提供したカード群を実装） ======= */
const CARD_POOL = [
  // Monsters
  {id:'M_SLIME', name:'スライム', type:'monster', cost:1, power:1, text:'登場時：デッキから「スライム」名のカード1枚をサーチして手札に加える'},
  {id:'M_ONIJIN', name:'鬼人', type:'monster', cost:4, power:4, text:'エンドフェイズ：相手モンスターの中から自分の攻撃力以下のモンスターを1体選び墓地へ送る'},
  {id:'M_NECRO', name:'ネクロマンサー', type:'monster', cost:5, power:3, text:'エンドフェイズ：自分の墓地からランダムに1体を蘇生する'},
  {id:'M_JUJUTSU', name:'呪術師', type:'monster', cost:3, power:2, text:'場にいる間、相手モンスターの効果を無効化する'},
  {id:'M_GOLEM', name:'ゴーレム', type:'monster', cost:3, power:4, text:'なし'},
  {id:'M_SP_GOLEM', name:'スピードゴーレム', type:'monster', cost:5, power:3, text:'このカードは1ターンに2回攻撃できる'},
  {id:'M_ATK_GOLEM', name:'アタックゴーレム', type:'monster', cost:5, power:5, text:'なし'},
  {id:'M_ULT_GOLEM', name:'アルティメットゴーレム', type:'monster', cost:20, power:6, text:'ゴーレム、スピードゴーレム、アタックゴーレムを生贄に捧げて特殊召喚できる。1ターンに2回攻撃'},
  {id:'M_ANT', name:'アント', type:'monster', cost:1, power:1, text:'登場時：デッキに「アントα」が存在する場合、その1枚を手札に加える'},
  {id:'M_ANT_A', name:'アントα', type:'monster', cost:1, power:1, text:'登場時：デッキから「アント」名のカード1枚を手札に加える'},
  {id:'M_IRON_ANT', name:'アイアンアント', type:'monster', cost:2, power:3, text:'なし'},
  {id:'M_GOLD_ANT', name:'ゴールドアント', type:'monster', cost:3, power:3, text:'効果発動：デッキから「アント」または「アントα」を1体選び場に召喚（召喚酔い無し）。カードごとに1回'},
  {id:'M_ANT_KING', name:'アントキング', type:'monster', cost:4, power:4, text:'効果発動：墓地から「アント」名のモンスターを最大2体選び召喚（召喚酔い無し）。カードごとに1回'},

  // Spells
  {id:'S_DARK_SAC', name:'ダークサクリファイス', type:'spell', cost:3, text:'自分のモンスター1体を墓地に送り、その攻撃力分相手モンスター1体の攻撃力を減少'},
  {id:'S_LIGHTNING', name:'雷撃', type:'spell', cost:4, text:'相手のモンスター1体を破壊'},
  {id:'S_RELIC', name:'亡者の遺品', type:'spell', cost:3, text:'墓地からカード1枚を手札に戻す'},
  {id:'S_ANT_EGG', name:'アントの卵', type:'spell', cost:2, text:'山札から「アント」名のカードを最大2枚手札に加える'},
  {id:'S_ANT_RETAL', name:'アントの逆襲', type:'spell', cost:2, text:'ターン中、自分の「アント」名のモンスター全ての攻撃力+1（終了時に戻る）'},
  {id:'S_ANT_GROW', name:'アントの育成', type:'spell', cost:2, text:'このターン中、自分の「アント」名のモンスターの召喚コスト-1'},
  {id:'S_SNIP', name:'狙い撃ち', type:'spell', cost:4, text:'相手の攻撃力4以下のモンスターを1体墓地へ'},
  {id:'S_RESEARCH', name:'博士の研究', type:'spell', cost:1, text:'2枚ドロー（このカードは1ターンに1度のみ使用可）'},
  {id:'S_MAGIC_SEARCH', name:'マジックサーチ', type:'spell', cost:1, text:'山札から魔法カード1枚を手札に加える（非公開）'},
  {id:'S_MONSTER_SEARCH', name:'モンスターサーチ', type:'spell', cost:1, text:'山札からモンスターカード1枚を手札に加える（非公開）'},
  {id:'S_ANT_AWAKEN', name:'アントの覚醒', type:'spell', cost:1, text:'自分の場にいる全ての「アント」名のモンスターの召喚酔いを解除'},

  // Field
  {id:'F_HAPPY_M', name:'ハッピーマウンテン', type:'field', cost:2, text:'エンドフェイズ：両者1枚ドロー。場に1枚のみ'},
  {id:'F_LOST_FOREST', name:'亡者の森', type:'field', cost:3, text:'エンドフェイズ：両者の墓地からランダムで1枚を手札に戻す。場に1枚のみ'},
  {id:'F_ANT_NEST', name:'アントの巣', type:'field', cost:2, text:'「アント」名のモンスターの攻撃力+1'},
  {id:'F_ANT_BREED', name:'アントの産卵場', type:'field', cost:3, text:'「アント」名のモンスターのコスト-1（両者）'}
];

/* ================= 状態管理（マッチ） ================= */
let storageKey = 'monsterArena_decks_v1';
let savedDecks = loadSavedDecks(); // {name: string, cards: [ids]}
let currentBuild = []; // array of card ids during editing

// Match state
let match = null; // will hold all runtime state when match starts

/* ================= ユーティリティ ================= */
function clone(obj){ return JSON.parse(JSON.stringify(obj)); }
function shuffle(a){ for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];} return a; }
function findCardById(id){ return clone(CARD_POOL.find(c=>c.id===id)); }
function countInDecklist(list, id){ return list.filter(x=>x===id).length; }

/* ================== UI: view switching ================== */
function showView(view){
  document.getElementById('viewMenu').style.display = (view==='viewMenu' || view===undefined)?'block':'none';
  document.getElementById('viewDeckEditor').style.display = view==='deckEditor' ? 'block' : 'none';
  document.getElementById('viewCpuMatch').style.display = view==='cpuMatch' ? 'block' : 'none';
  document.getElementById('viewRule').style.display = view==='ruleView' ? 'block' : 'none';
  // populate lists when showing specific views
  if(view==='deckEditor') renderAllCards(), renderDeckList(), renderSavedDecksUI();
  if(view==='viewMenu' || view===undefined) renderSavedDecksList();
  if(view==='cpuMatch') populateDeckSelect();
}

/* ================== LocalStorage: save/load decks ================== */
function loadSavedDecks(){
  try {
    const raw = localStorage.getItem(storageKey);
    return raw ? JSON.parse(raw) : [];
  } catch(e){ return []; }
}
function saveSavedDecks(){
  localStorage.setItem(storageKey, JSON.stringify(savedDecks));
}
function saveDeck(){
  const name = document.getElementById('deckNameInput').value.trim();
  if(!name){ alert('デッキ名を入力してください'); return; }
  if(currentBuild.length !== 50){ alert('デッキは50枚にしてください（現在 '+currentBuild.length+' 枚）'); return; }
  // check max 4 copies
  for(const id of new Set(currentBuild)){
    if(countInDecklist(currentBuild,id) > 4){ alert('カード '+ findCardById(id).name +' が4枚を超えています'); return; }
  }
  // save (overwrite if same name)
  const existingIdx = savedDecks.findIndex(d=>d.name===name);
  const deckObj = {name, cards: [...currentBuild]};
  if(existingIdx!==-1) savedDecks[existingIdx] = deckObj;
  else savedDecks.push(deckObj);
  saveSavedDecks();
  renderSavedDecksUI();
  renderSavedDecksList();
  alert('保存しました: '+name);
}
function deleteSavedDeck(name){
  if(!confirm('デッキ「'+name+'」を削除しますか？')) return;
  savedDecks = savedDecks.filter(d=>d.name!==name);
  saveSavedDecks();
  renderSavedDecksUI();
  renderSavedDecksList();
}
function loadDeckToEditor(name){
  const deck = savedDecks.find(d=>d.name===name);
  if(!deck) return;
  currentBuild = [...deck.cards];
  document.getElementById('deckNameInput').value = deck.name;
  renderDeckList();
}

/* quick save currentBuild into a generated quick name */
function quickSaveDefault(){
  const name = 'QuickDeck_'+(new Date()).toISOString().slice(0,19).replace(/[:T]/g,'_');
  if(currentBuild.length !== 50){ alert('現在のデッキ枚数が50ではありません。保存できません。'); return; }
  savedDecks.push({name, cards:[...currentBuild]});
  saveSavedDecks();
  renderSavedDecksUI();
  renderSavedDecksList();
  alert('クイック保存しました：'+name);
}

/* ================== Render functions for editor/menu ================== */
function renderAllCards(){
  const area = document.getElementById('allCardsArea');
  area.innerHTML = '';
  document.getElementById('cardPoolCount').textContent = CARD_POOL.length;
  CARD_POOL.forEach(c=>{
    const el = document.createElement('div');
    el.className = 'cardCompact';
    el.innerHTML = `<div style="display:flex;justify-content:space-between"><div style="font-weight:700">${c.name}</div><div class="smallMuted">${c.type.toUpperCase()}</div></div>
      <div class="smallMuted">cost:${c.cost}${c.power? ' / atk:'+c.power : ''}</div>
      <div style="margin-top:6px;font-size:13px;color:#222">${c.text ?? ''}</div>
      <div style="margin-top:6px"><button class="btn small" onclick="addCardToDeck('${c.id}')">追加</button></div>`;
    area.appendChild(el);
  });
}
function renderDeckList(){
  const area = document.getElementById('deckListArea');
  area.innerHTML = '';
  document.getElementById('currentDeckCount').textContent = currentBuild.length;
  // list by groups
  const grouped = {};
  currentBuild.forEach(id=> grouped[id] = (grouped[id]||0)+1);
  Object.keys(grouped).forEach(id=>{
    const c = findCardById(id);
    const el = document.createElement('div');
    el.className = 'cardCompact';
    el.innerHTML = `<div style="display:flex;justify-content:space-between"><div style="font-weight:700">${c.name}</div><div class="smallMuted">${grouped[id]} 枚</div></div>
      <div class="smallMuted">${c.type} cost:${c.cost}${c.power? ' / atk:'+c.power : ''}</div>
      <div style="margin-top:6px"><button class="btn small" onclick="removeOneFromDeck('${id}')">−</button></div>`;
    area.appendChild(el);
  });
}
function renderSavedDecksUI(){
  const area = document.getElementById('savedDecks');
  area.innerHTML = '';
  savedDecks.forEach(d=>{
    const el = document.createElement('div');
    el.className = 'cardCompact';
    el.style.display='flex'; el.style.justifyContent='space-between'; el.style.alignItems='center';
    el.innerHTML = `<div style="flex:1"><div style="font-weight:700">${d.name}</div><div class="smallMuted">${d.cards.length} 枚</div></div>
      <div style="display:flex;flex-direction:column;gap:6px"><button class="btn small" onclick="loadDeckToEditor('${d.name}')">読み込み</button><button class="btn small" onclick="deleteSavedDeck('${d.name}')">削除</button></div>`;
    area.appendChild(el);
  });
}
function renderSavedDecksList(){
  const area = document.getElementById('savedDecksList');
  area.innerHTML = '';
  savedDecks.forEach(d=>{
    const btn = document.createElement('button');
    btn.className = 'btn small';
    btn.textContent = d.name;
    btn.onclick = ()=>{ document.getElementById('deckSelect').value = d.name; showView('cpuMatch'); populateDeckSelect(); };
    area.appendChild(btn);
  });
}

/* ================= Deck editing helpers ================= */
function addCardToDeck(id){
  if(currentBuild.length >= 50){ alert('デッキは50枚までです'); return; }
  if(countInDecklist(currentBuild,id) >= 4){ alert('同一カードは最大4枚までです'); return; }
  currentBuild.push(id);
  renderDeckList();
}
function removeOneFromDeck(id){
  const i = currentBuild.findIndex(x=>x===id);
  if(i>=0) currentBuild.splice(i,1);
  renderDeckList();
}
function clearDeck(){ if(confirm('デッキをクリアしますか？')){ currentBuild=[]; document.getElementById('deckNameInput').value=''; renderDeckList(); } }

/* ================= CPU Match: setup and runtime ================= */
function populateDeckSelect(){
  const select = document.getElementById('deckSelect');
  select.innerHTML = '';
  const opt = document.createElement('option'); opt.value='__none__'; opt.textContent='-- デッキを選択 --'; select.appendChild(opt);
  savedDecks.forEach(d=>{
    const o = document.createElement('option'); o.value = d.name; o.textContent = d.name; select.appendChild(o);
  });
}

/* Build a 50-card deck array (ids) for player and CPU */
function buildDeckFromSaved(name){
  const obj = savedDecks.find(d=>d.name===name);
  if(!obj) return null;
  // return a shallow clone
  return [...obj.cards];
}
function buildRandomCpuDeck(){
  // Create a pool where each card id can be used up to 4 times
  let pool = [];
  CARD_POOL.forEach(c=>{
    for(let i=0;i<4;i++) pool.push(c.id);
  });
  shuffle(pool);
  // pick first 50
  const deck = pool.slice(0,50);
  return deck;
}

/* start match */
function startMatch(){
  const sel = document.getElementById('deckSelect').value;
  if(!sel || sel === '__none__'){ alert('対戦に使う保存デッキを選んでください'); return; }
  const playerDeck = buildDeckFromSaved(sel);
  if(!playerDeck || playerDeck.length!==50){ alert('選択デッキが不正です（50枚であること）'); return; }
  const cpuDeck = buildRandomCpuDeck();
  // initial match state
  match = {
    turn: 0,
    phase: 'start',
    player: {
      deck: shuffle(playerDeck.slice()),
      hand: [],
      grave: [],
      battle: [null,null,null],
      field: null,
      shield: 7,
      mana: {current:0,max:0},
      researched: false,
      antCostReduce:0,
    },
    cpu: {
      deck: shuffle(cpuDeck.slice()),
      hand: [],
      grave: [],
      battle: [null,null,null],
      field: null,
      shield: 7,
      mana: {current:0,max:0},
      researched:false,
      antCostReduce:0,
    },
    active: document.getElementById('whoGoesFirst').value === 'player' ? 'player' : 'cpu',
    log: [],
    history: []
  };
  // initial draws 5 each
  for(let i=0;i<5;i++){ drawFor('player'); drawFor('cpu'); }
  match.turn = 1;
  updateManaForMatch();
  updateAllUI();
  document.getElementById('endTurnBtnMatch').disabled = false;
  logMatch('対戦開始: あなたのデッキ「'+sel+'」 vs CPU（ランダム）');
  document.getElementById('infoMode').textContent = '対戦中';
  // if CPU starts, run CPU turn
  if(match.active === 'cpu'){ setTimeout(() => cpuTakeTurn(), 400); }
}

/* Draw */
function drawFor(side){
  if(!match) return;
  const s = match[side];
  if(s.deck.length === 0){
    // deck out => lose
    if(side === 'player'){ alert('あなたの山札が無くなりました。敗北です。'); resetToMenu(); return; }
    else { alert('CPUの山札が無くなりました。あなたの勝利です！'); resetToMenu(); return; }
  }
  const id = s.deck.shift();
  const card = findCardById(id);
  s.hand.push(card);
  logMatch((side==='player'?'あなた':'CPU')+'は1枚ドロー：'+card.name);
  updateAllUI();
}

/* End turn handler */
function endTurn(){
  if(!match) return;
  // if active is player, end-> cpu; if cpu, end-> player
  if(match.active === 'player'){
    resolveEndPhase('player');
    match.active = 'cpu';
    updateAllUI();
    setTimeout(()=> cpuTakeTurn(), 300);
  } else {
    // shouldn't be clickable
  }
}

/* Forfeit */
function forfeitMatch(){ if(!match) return; if(confirm('降参しますか？')){ alert('あなたの敗北です'); resetToMenu(); } }

/* Shuffle Player Deck */
function shufflePlayerDeck(){ if(!match) return; match.player.deck = shuffle(match.player.deck); logMatch('あなたはデッキをシャッフルした'); updateAllUI(); }

/* Reset to main menu after match end */
function resetToMenu(){
  match = null;
  document.getElementById('endTurnBtnMatch').disabled = true;
  document.getElementById('infoMode').textContent = '待機';
  showView('viewMenu');
  renderSavedDecksList();
}

/* Update Mana according to turn rules */
function updateManaForMatch(){
  if(!match) return;
  const t = match.turn;
  // t counts overall increments; we will map to player-first-turn logic: if player started as first active, use mapping
  // We will consider "round" as half-turn increments. Simpler: maintain conceptual "round number" where player first turn is round1.
  // For simplicity, when match.turn ===1, we set per agreement: playerMax=1, cpuMax=2 if player started; if cpu started invert
  let pMax=1, cMax=2;
  // determine who is initial starter (when match.turn started)
  const starter = document.getElementById('whoGoesFirst').value;
  // compute 'turnNumber' of each player's personal turns by counting how many times they gained mana
  // simpler rule mapping (from earlier decisions):
  // If it's the first global turn:
  if(match.turn === 1){
    if(starter === 'player'){ pMax=1; cMax=2; }
    else { pMax=2; cMax=1; }
  } else if(match.turn === 2){
    // second increment: both 2
    pMax=2; cMax=2;
  } else {
    pMax=3; cMax=3;
  }
  match.player.mana.max = pMax; match.player.mana.current = pMax;
  match.cpu.mana.max = cMax; match.cpu.mana.current = cMax;
  // reset per-turn flags
  match.player.researched=false; match.cpu.researched=false;
  match.player.antCostReduce = match.player.antCostReduce || 0;
  match.cpu.antCostReduce = match.cpu.antCostReduce || 0;
}

/* Log/History */
function logMatch(msg){
  if(!match){ console.log(msg); return; }
  match.log.unshift(msg);
  if(match.log.length > 500) match.log.pop();
  // also append to history list
  match.history.unshift({time:(new Date()).toLocaleTimeString(), text:msg});
  if(match.history.length > 500) match.history.pop();
  updateAllUI();
}
function renderHistory(){ const el = document.getElementById('historyList'); el.innerHTML=''; if(!match) return; match.history.slice(0,200).forEach(h=>{ const div = document.createElement('div'); div.className='smallMuted'; div.style.padding='4px 0'; div.textContent = `[${h.time}] ${h.text}`; el.appendChild(div); }); }

/* Update all UI */
function updateAllUI(){
  if(!match){
    // update deck lists counters etc.
    document.getElementById('playerDeckUI').textContent = '-';
    document.getElementById('cpuDeckUI').textContent = '-';
    return;
  }
  document.getElementById('uiTurn').textContent = match.turn;
  // counts
  document.getElementById('playerDeckUI').textContent = match.player.deck.length;
  document.getElementById('cpuDeckUI').textContent = match.cpu.deck.length;
  document.getElementById('playerShieldUI').textContent = match.player.shield;
  document.getElementById('cpuShieldUI').textContent = match.cpu.shield;
  document.getElementById('playerGraveUI').textContent = match.player.grave.length;
  document.getElementById('cpuGraveUI').textContent = match.cpu.grave.length;
  document.getElementById('playerManaUI').textContent = match.player.mana.current + '/' + match.player.mana.max;
  document.getElementById('cpuManaUI').textContent = match.cpu.mana.current + '/' + match.cpu.mana.max;
  // fields
  document.getElementById('playerFieldUI').innerHTML = match.player.field ? `<span class="fieldCard">${match.player.field.name}</span>` : 'なし';
  document.getElementById('cpuFieldUI').innerHTML = match.cpu.field ? `<span class="fieldCard">${match.cpu.field.name}</span>` : 'なし';
  // battle rows
  const pRow = document.getElementById('playerBattleRow'); pRow.innerHTML='';
  match.player.battle.forEach((b,idx)=>{
    const slot = document.createElement('div'); slot.className='battleSlot';
    if(b){
      const inner = document.createElement('div'); inner.className='slotCard';
      inner.innerHTML = `<div style="font-weight:700">${b.name}</div><div class="smallMuted">atk:${b.power}</div>
        <div style="margin-top:6px"><button class="btn small" onclick="onPlayerAttack(${idx})">攻撃</button>${b.canActivate? ' <button class="btn small" onclick="onPlayerActivate('+idx+')">効果発動</button>':''}</div>`;
      slot.appendChild(inner);
    } else slot.innerHTML = '<div class="smallMuted">空</div>';
    pRow.appendChild(slot);
  });
  const cRow = document.getElementById('cpuBattleRow'); cRow.innerHTML='';
  match.cpu.battle.forEach((b,idx)=>{
    const slot = document.createElement('div'); slot.className='battleSlot';
    if(b){
      const inner = document.createElement('div'); inner.className='slotCard';
      inner.innerHTML = `<div style="font-weight:700">${b.name}</div><div class="smallMuted">atk:${b.power}</div>`;
      slot.appendChild(inner);
    } else slot.innerHTML = '<div class="smallMuted">空</div>';
    cRow.appendChild(slot);
  });
  // hand
  const handArea = document.getElementById('playerHandUI'); handArea.innerHTML='';
  match.player.hand.forEach((c,i)=>{
    const el = document.createElement('div'); el.className='cardUI';
    el.innerHTML = `<div style="font-weight:700">${c.name}</div><div class="smallMuted">cost:${c.cost}${c.power? ' / atk:'+c.power:''}</div>
      <div style="margin-top:6px;font-size:13px;color:#222">${c.text}</div>
      <div style="margin-top:6px"><button class="btn small" onclick="playCardFromHand(${i})">使用</button></div>`;
    handArea.appendChild(el);
  });
  // match log
  const logEl = document.getElementById('matchLog'); logEl.innerHTML = match.log.map(l=>`<div>${l}</div>`).join('');
  renderHistory();
}

/* Play card from hand (player) */
function playCardFromHand(index){
  if(!match) return;
  if(match.active !== 'player'){ alert('あなたのターンではありません'); return; }
  const card = match.player.hand[index];
  if(!card) return;
  // determine effective cost (ant cost reduce)
  let cost = card.cost || 0;
  if(card.name.includes('アント') && match.player.antCostReduce) cost = Math.max(0, cost - match.player.antCostReduce);
  if(cost > match.player.mana.current){ alert('マナが足りません'); return; }
  if(card.type === 'monster'){
    // find empty slot
    const slot = match.player.battle.findIndex(b=>b===null);
    if(slot === -1){ alert('バトルゾーンの空きがありません'); return; }
    // special ultimate golem handling: requires sacrificing named monsters on field (we check both field and grave? spec said on field)
    if(card.id === 'M_ULT_GOLEM'){
      const names = ['ゴーレム','スピードゴーレム','アタックゴーレム'];
      const present = match.player.battle.filter(b=>b && names.includes(b.name));
      if(present.length < 3){ alert('アルティメットゴーレムの召喚にはゴーレム系3体が必要です'); return; }
      // sacrifice one each
      let used=0;
      for(let i=0;i<match.player.battle.length && used<3;i++){
        const b = match.player.battle[i];
        if(b && names.includes(b.name)){
          match.player.grave.push(b);
          match.player.battle[i] = null;
          used++;
        }
      }
      const newCard = clone(card); newCard.summonSick = false; newCard.attacksLeft = 2; newCard.canActivate = false;
      match.player.battle[slot] = newCard;
      match.player.hand.splice(index,1);
      logMatch('アルティメットゴーレムを特殊召喚した（生贄を捧げた）');
      updateAllUI();
      return;
    }
    // normal summon
    match.player.mana.current -= cost;
    const newCard = clone(card);
    newCard.summonSick = true; // cannot attack this turn unless effect
    if(newCard.id === 'M_GOLD_ANT' || newCard.id === 'M_ANT_KING') newCard.canActivate = true;
    if(newCard.id === 'M_SP_GOLEM') newCard.attacksLeft = 2;
    match.player.battle[slot] = newCard;
    match.player.hand.splice(index,1);
    logMatch('あなたは'+newCard.name+'を召喚した');
    // handle enter effects
    handleEnterEffect('player', newCard);
    updateAllUI();
  } else if(card.type === 'spell'){
    match.player.mana.current -= cost;
    match.player.hand.splice(index,1);
    match.player.grave.push(card);
    logMatch('あなたは魔法'+card.name+'を使用した');
    resolveSpell('player', card);
    updateAllUI();
  } else if(card.type === 'field'){
    if(match.player.field){ alert('既にフィールドが存在します'); return; }
    match.player.mana.current -= cost;
    match.player.field = clone(card);
    match.player.hand.splice(index,1);
    logMatch('あなたはフィールド'+card.name+'を設置した');
    updateAllUI();
  }
}

/* handle enter/trigger effects for certain cards */
function handleEnterEffect(side, card){
  if(!card || !card.text) return;
  if(card.id === 'M_SLIME'){
    const deck = match[side].deck;
    const idx = deck.findIndex(id=> findCardById(id).name.includes('スライム'));
    if(idx!==-1){
      const found = findCardById(deck.splice(idx,1)[0]);
      match[side].hand.push(found);
      logMatch((side==='player'?'あなた':'CPU')+'はデッキから'+found.name+'をサーチした');
    }
  }
  if(card.id === 'M_ANT'){
    const deck = match[side].deck;
    const idx = deck.findIndex(id=> findCardById(id).name === 'アントα');
    if(idx!==-1){
      const found = findCardById(deck.splice(idx,1)[0]);
      match[side].hand.push(found);
      logMatch((side==='player'?'あなた':'CPU')+'はデッキから'+found.name+'を手札に加えた');
    }
  }
  if(card.id === 'M_ANT_A'){
    const deck = match[side].deck;
    const idx = deck.findIndex(id=> findCardById(id).name.includes('アント') && findCardById(id).name !== 'アントα');
    if(idx!==-1){
      const found = findCardById(deck.splice(idx,1)[0]);
      match[side].hand.push(found);
      logMatch((side==='player'?'あなた':'CPU')+'はデッキから'+found.name+'を手札に加えた');
    }
  }
}

/* Resolve spells (simplified but functional) */
function resolveSpell(side, spell){
  const opp = side==='player' ? 'cpu' : 'player';
  switch(spell.id){
    case 'S_LIGHTNING': {
      // choose strongest opponent monster if exists
      const candidates = match[opp].battle.map((b,idx)=> b ? {b,idx} : null).filter(Boolean);
      if(candidates.length===0){ logMatch('雷撃の対象がいませんでした'); return; }
      // pick highest power
      candidates.sort((a,b)=> (b.b.power||0)-(a.b.power||0));
      const removed = candidates[0].b;
      match[opp].grave.push(removed);
      match[opp].battle[candidates[0].idx] = null;
      logMatch((side==='player'?'あなた':'相手')+'の雷撃で'+removed.name+'を破壊した');
      break;
    }
    case 'S_RELIC': {
      if(match[side].grave.length>0){
        const c = match[side].grave.pop();
        match[side].hand.push(clone(c));
        logMatch((side==='player'?'あなた':'相手')+'は亡者の遺品で'+c.name+'を手札に戻した');
      } else logMatch('墓地にカードがありません');
      break;
    }
    case 'S_DARK_SAC': {
      // sacrifice own lowest-power monster and reduce one opponent monster by that amount
      const ownCandidates = match[side].battle.map((b,idx)=> b ? {b,idx} : null).filter(Boolean);
      const oppCandidates = match[opp].battle.map((b,idx)=> b ? {b,idx} : null).filter(Boolean);
      if(ownCandidates.length===0 || oppCandidates.length===0){ logMatch('ダークサクリファイスの対象が揃っていません'); return; }
      ownCandidates.sort((a,b)=> (a.b.power||0)-(b.b.power||0));
      oppCandidates.sort((a,b)=> (b.b.power||0)-(a.b.power||0));
      const sac = ownCandidates[0];
      const targ = oppCandidates[0];
      match[side].grave.push(sac.b);
      match[side].battle[sac.idx] = null;
      match[opp].battle[targ.idx].power = Math.max(0, (match[opp].battle[targ.idx].power||0) - (sac.b.power||0));
      logMatch((side==='player'?'あなた':'相手')+'は'+sac.b.name+'を捧げ、'+targ.b.name+'の攻撃力を'+sac.b.power+'減少させた');
      break;
    }
    case 'S_ANT_EGG': {
      for(let k=0;k<2;k++){
        const idx = match[side].deck.findIndex(id=> findCardById(id).name.includes('アント'));
        if(idx!==-1){
          const found = findCardById(match[side].deck.splice(idx,1)[0]);
          match[side].hand.push(found);
          logMatch((side==='player'?'あなた':'相手')+'はアントの卵で'+found.name+'を手札に加えた');
        }
      }
      shuffle(match[side].deck);
      break;
    }
    case 'S_ANT_RETAL': {
      match[side].battle.forEach(b=>{ if(b && b.name.includes('アント')) b.power = (b.power||0)+1; });
      // mark a revert flag
      match[side].antRetalActive = true;
      logMatch((side==='player'?'あなた':'相手')+'のアント達の攻撃力が+1された（ターン終了で戻る）');
      break;
    }
    case 'S_ANT_GROW': {
      match[side].antCostReduce = (match[side].antCostReduce||0)+1;
      logMatch((side==='player'?'あなた':'相手')+'はアントの育成でアントのコストを-1した（今ターン）');
      break;
    }
    case 'S_SNIP': {
      const idx = match[opp].battle.findIndex(b=> b && (b.power||0) <= 4);
      if(idx!==-1){
        const removed = match[opp].battle[idx];
        match[opp].grave.push(removed);
        match[opp].battle[idx] = null;
        logMatch((side==='player'?'あなた':'相手')+'は狙い撃ちで'+removed.name+'を墓地へ送った');
      } else logMatch('狙い撃ちの対象が見つかりませんでした');
      break;
    }
    case 'S_RESEARCH': {
      if(match[side].researched){ logMatch('博士の研究は今ターン既に使われました'); return; }
      drawFor(side); drawFor(side);
      match[side].researched = true;
      logMatch((side==='player'?'あなた':'相手')+'は博士の研究で2枚ドローした');
      break;
    }
    case 'S_MAGIC_SEARCH': {
      const idx = match[side].deck.findIndex(id=> findCardById(id).type === 'spell');
      if(idx!==-1){
        const found = findCardById(match[side].deck.splice(idx,1)[0]);
        match[side].hand.push(found);
        logMatch((side==='player'?'あなた':'相手')+'は魔法1枚をサーチした');
      } else logMatch('魔法が見つかりませんでした');
      break;
    }
    case 'S_MONSTER_SEARCH': {
      const idx = match[side].deck.findIndex(id=> findCardById(id).type === 'monster');
      if(idx!==-1){
        const found = findCardById(match[side].deck.splice(idx,1)[0]);
        match[side].hand.push(found);
        logMatch((side==='player'?'あなた':'相手')+'はモンスターを1枚サーチした');
      } else logMatch('モンスターが見つかりませんでした');
      break;
    }
    case 'S_ANT_AWAKEN': {
      match[side].battle.forEach(b=>{ if(b && b.name.includes('アント')) b.summonSick = false; });
      logMatch((side==='player'?'あなた':'相手')+'はアントの覚醒で召喚酔いを解除した');
      break;
    }
    default:
      logMatch('未実装の魔法効果: '+spell.name);
  }
}

/* handle end-phase triggers */
function resolveEndPhase(side){
  // resolve monster end-of-turn effects: OniJin and Necro
  match[side].battle.forEach((c,idx)=>{
    if(!c) return;
    if(c.id === 'M_ONIJIN'){
      // choose first opponent monster with atk <= c.power
      const opp = side==='player' ? match.cpu : match.player;
      const candidates = opp.battle.map((b,i)=> b && (b.power||0) <= (c.power||0) ? i : -1).filter(v=>v!==-1);
      if(candidates.length>0){
        const chosenIdx = candidates[0];
        const removed = opp.battle[chosenIdx];
        opp.grave.push(removed);
        opp.battle[chosenIdx] = null;
        logMatch((side==='player'?'あなた':'相手')+'の鬼人で'+removed.name+'を墓地へ送った');
      }
    }
    if(c.id === 'M_NECRO'){
      const g = match[side].grave;
      if(g.length>0){
        const idx = Math.floor(Math.random()*g.length);
        const card = g.splice(idx,1)[0];
        // place if slot available
        const slot = match[side].battle.findIndex(b=>b===null);
        if(slot!==-1){
          card.summonSick = true;
          match[side].battle[slot] = card;
          logMatch((side==='player'?'あなた':'相手')+'のネクロマンサーが'+card.name+'を蘇生した');
        } else {
          g.push(card);
        }
      }
    }
  });
  // field effects (if player's own field is certain ones)
  // We interpret F_HAPPY_M (both draw 1), F_LOST_FOREST (both return random from grave to hand)
  if(match.player.field && match.player.field.id === 'F_HAPPY_M'){
    drawFor('player'); drawFor('cpu'); logMatch('ハッピーマウンテン効果：両者1枚ドロー');
  }
  if(match.player.field && match.player.field.id === 'F_LOST_FOREST'){
    ['player','cpu'].forEach(s=>{
      if(match[s].grave.length>0){
        const idx = Math.floor(Math.random()*match[s].grave.length);
        const c = match[s].grave.splice(idx,1)[0];
        match[s].hand.push(c);
        logMatch((s==='player'?'あなた':'相手')+'は亡者の森で'+c.name+'を手札に戻した');
      }
    });
  }
  // revert ephemeral buffs like antRetal
  if(match.player.antRetalActive){
    // revert: we simply subtract 1 from any ant that got buffed - note: may slightly under/over if other buffs changed, but acceptable for prototype
    match.player.battle.forEach(b=>{ if(b && b.name.includes('アント')) b.power = Math.max(0,(b.power||0)-1); });
    match.player.antRetalActive = false;
  }
  if(match.cpu.antRetalActive){
    match.cpu.battle.forEach(b=>{ if(b && b.name.includes('アント')) b.power = Math.max(0,(b.power||0)-1); });
    match.cpu.antRetalActive = false;
  }
  // advance turn count and mana
  match.turn++;
  updateManaForMatch();
}

/* Player attack flow: select attacker slot */
let selectedAttackerSlot = null;
function onPlayerAttack(slotIdx){
  if(!match) return;
  if(match.active !== 'player'){ alert('あなたのターンではありません'); return; }
  const mon = match.player.battle[slotIdx];
  if(!mon){ alert('そのスロットにモンスターはいません'); return; }
  if(mon.summonSick){ alert('このターンは召喚酔いしています'); return; }
  selectedAttackerSlot = slotIdx;
  logMatch('攻撃する相手を選択してください（相手モンスターをクリック、またはダイレクト）');
  // make cpu slots clickable
  const cpuSlots = document.getElementById('cpuBattleRow').children;
  for(let i=0;i<cpuSlots.length;i++){
    cpuSlots[i].classList.add('targetable');
    cpuSlots[i].onclick = ()=> playerAttackTarget(i);
  }
  // allow direct attack checking
  const canDirect = match.cpu.battle.every(s=>s===null) && match.cpu.shield === 0;
  if(canDirect){
    if(confirm('条件を満たしています。相手にダイレクトアタックして勝利しますか？（OKで実行）')){
      alert('ダイレクトアタック成功！あなたの勝利です！');
      resetToMenu();
      return;
    }
  }
}
function playerAttackTarget(targetIdx){
  if(selectedAttackerSlot === null) return;
  const attacker = match.player.battle[selectedAttackerSlot];
  const defender = match.cpu.battle[targetIdx];
  if(!attacker || !defender){ logMatch('不正な攻撃対象'); clearAttackTargets(); return; }
  const a = attacker.power || 0;
  const d = defender.power || 0;
  if(a > d){
    match.cpu.grave.push(defender); match.cpu.battle[targetIdx] = null;
    logMatch(attacker.name+'('+a+') は '+defender.name+'('+d+') を破壊した');
  } else if(a < d){
    match.player.grave.push(attacker); match.player.battle[selectedAttackerSlot] = null;
    logMatch(attacker.name+'('+a+') は '+defender.name+'('+d+') に敗れ、墓地へ');
  } else {
    match.cpu.grave.push(defender); match.cpu.battle[targetIdx] = null;
    match.player.grave.push(attacker); match.player.battle[selectedAttackerSlot] = null;
    logMatch(attacker.name+' と '+defender.name+' は互いに消滅した');
  }
  clearAttackTargets();
  updateAllUI();
}
function clearAttackTargets(){
  selectedAttackerSlot = null;
  const cpuSlots = document.getElementById('cpuBattleRow').children;
  for(let i=0;i<cpuSlots.length;i++){
    cpuSlots[i].classList.remove('targetable'); cpuSlots[i].onclick = null;
  }
}

/* Player activate effect from slot (Gold Ant / Ant King) */
function onPlayerActivate(slotIdx){
  const card = match.player.battle[slotIdx];
  if(!card || !card.canActivate) return;
  if(card.id === 'M_GOLD_ANT'){
    // search deck for ant or ant alpha
    const idx = match.player.deck.findIndex(id=> findCardById(id).name.includes('アント'));
    if(idx!==-1){
      const found = findCardById(match.player.deck.splice(idx,1)[0]);
      const s = match.player.battle.findIndex(b=>b===null);
      if(s!==-1){
        found.summonSick = false;
        match.player.battle[s] = found;
        logMatch('ゴールドアントで'+found.name+'を場に召喚（召喚酔い無し）');
      } else {
        logMatch('場に空きがないため召喚できませんでした');
      }
    } else logMatch('デッキにアントが見つかりません');
    card.canActivate = false;
    updateAllUI();
  }
  if(card.id === 'M_ANT_KING'){
    const ants = match.player.grave.filter(c=> c.name.includes('アント'));
    if(ants.length===0){ logMatch('墓地にアントがいません'); return; }
    const toRes = ants.slice(0,2);
    toRes.forEach(r=>{
      const s = match.player.battle.findIndex(b=>b===null);
      if(s!==-1){
        // remove from grave
        const idx = match.player.grave.findIndex(g=>g === r);
        const rc = match.player.grave.splice(idx,1)[0];
        rc.summonSick = false;
        match.player.battle[s] = rc;
        logMatch('アントキングで'+rc.name+'を墓地から召喚（召喚酔い無し）');
      }
    });
    card.canActivate = false; updateAllUI();
  }
}

/* CPU logic (moderate intelligence) */
function cpuTakeTurn(){
  if(!match) return;
  logMatch('---- CPUのターン開始 ----');
  // set active
  match.active = 'cpu';
  // draw
  drawFor('cpu');
  // update mana
  updateManaForMatch();
  // play field if none
  const cpu = match.cpu;
  // order: play highest-priority spells (removal/board) if beneficial, then play monsters by priority (power/cost)
  // simple heuristics:
  // 1) If CPU has removal (lightning/snip) and player has strong target, use it
  const playerStrong = match.player.battle.filter(b=>b).sort((a,b)=> (b.power||0)-(a.power||0))[0];
  // evaluate spells playable
  const playableSpells = cpu.hand.filter(c=> c.type==='spell' && (c.cost||0) <= cpu.mana.current);
  // removal preference
  const lightningIdx = playableSpells.findIndex(s=> s.id === 'S_LIGHTNING');
  if(lightningIdx !== -1 && playerStrong){
    // use lightning
    const sp = playableSpells[lightningIdx];
    cpu.mana.current -= sp.cost;
    cpu.hand.splice(cpu.hand.findIndex(h=>h.id===sp.id),1);
    cpu.grave.push(sp);
    resolveSpell('cpu', sp);
  }
  // snip for small threats
  const snipIdx = playableSpells.findIndex(s=> s.id === 'S_SNIP');
  if(snipIdx !== -1){
    const small = match.player.battle.find(b=> b && (b.power||0) <= 4);
    if(small){
      const sp = playableSpells[snipIdx];
      cpu.mana.current -= sp.cost;
      cpu.hand.splice(cpu.hand.findIndex(h=>h.id===sp.id),1);
      cpu.grave.push(sp);
      resolveSpell('cpu', sp);
    }
  }
  // research if low on cards and has cost 1 research and hasn't used
  const researchIdx = playableSpells.findIndex(s=> s.id === 'S_RESEARCH');
  if(researchIdx !== -1 && cpu.hand.length < 3 && !cpu.researched){
    const sp = playableSpells[researchIdx];
    cpu.mana.current -= sp.cost;
    cpu.hand.splice(cpu.hand.findIndex(h=>h.id===sp.id),1);
    cpu.grave.push(sp);
    resolveSpell('cpu', sp);
  }
  // place field if none and affordable
  const fieldIdx = cpu.hand.findIndex(c=> c.type==='field' && (c.cost||0) <= cpu.mana.current);
  if(fieldIdx !== -1 && !cpu.field){
    const f = cpu.hand.splice(fieldIdx,1)[0];
    cpu.mana.current -= f.cost;
    cpu.field = f;
    logMatch('CPUはフィールド'+f.name+'を設置した');
  }
  // summon monsters greedily by value (power per cost), prefer highest power fitting mana and slot
  const monsterCandidates = cpu.hand.filter(c=> c.type==='monster' && (c.cost||0) <= cpu.mana.current);
  monsterCandidates.sort((a,b)=> ((b.power||0)/(b.cost||1)) - ((a.power||0)/(a.cost||1)));
  for(const m of monsterCandidates){
    const slot = cpu.battle.findIndex(s=>s===null);
    if(slot===-1) break;
    // special handling: if Ultimate Golem possible via sacrifices on field, CPU may attempt if has the pieces
    if(m.id === 'M_ULT_GOLEM'){
      const names = ['ゴーレム','スピードゴーレム','アタックゴーレム'];
      const present = cpu.battle.filter(b=>b && names.includes(b.name));
      if(present.length < 3) continue;
      // sacrifice and summon
      let used=0;
      for(let i=0;i<cpu.battle.length && used<3;i++){
        const b = cpu.battle[i];
        if(b && names.includes(b.name)){
          cpu.grave.push(b);
          cpu.battle[i]=null; used++;
        }
      }
      const newCard = clone(m); newCard.summonSick = false; newCard.attacksLeft = 2;
      cpu.battle[slot] = newCard;
      // remove card from hand (one instance)
      const idx = cpu.hand.findIndex(h=>h.id===m.id);
      if(idx!==-1) cpu.hand.splice(idx,1);
      logMatch('CPUはアルティメットゴーレムを特殊召喚した');
      continue;
    }
    // normal summon
    cpu.mana.current -= m.cost;
    const idx = cpu.hand.findIndex(h=>h.id===m.id);
    const newCard = clone(m); newCard.summonSick = true;
    if(newCard.id === 'M_GOLD_ANT' || newCard.id === 'M_ANT_KING') newCard.canActivate = true;
    cpu.battle[slot] = newCard;
    if(idx!==-1) cpu.hand.splice(idx,1);
    logMatch('CPUは'+m.name+'を召喚した');
  }
  // CPU activate possible activations like Gold Ant / Ant King (simple)
  cpu.battle.forEach((b,idx)=>{
    if(b && b.canActivate){
      if(b.id === 'M_GOLD_ANT'){
        const idd = cpu.deck.findIndex(id=> findCardById(id).name.includes('アント'));
        if(idd!==-1){
          const found = findCardById(cpu.deck.splice(idd,1)[0]);
          const s = cpu.battle.findIndex(x=>x===null);
          if(s!==-1){
            found.summonSick=false; cpu.battle[s]=found;
            logMatch('CPUがゴールドアントの効果で'+found.name+'を召喚（召喚酔い無し）');
          }
        }
        b.canActivate = false;
      }
      if(b.id === 'M_ANT_KING'){
        const ants = cpu.grave.filter(c=> c.name.includes('アント'));
        if(ants.length>0){
          const toRes = ants.slice(0,2);
          toRes.forEach(r=>{
            const s = cpu.battle.findIndex(x=>x===null);
            if(s!==-1){
              const idx = cpu.grave.findIndex(g=>g === r);
              const rc = cpu.grave.splice(idx,1)[0]; rc.summonSick=false; cpu.battle[s]=rc;
              logMatch('CPUがアントキングで'+rc.name+'を蘇生（召喚酔い無し）');
            }
          });
        }
        b.canActivate=false;
      }
    }
  });

  // CPU attacks: for each monster without summonSick, attack using heuristics
  for(let i=0;i<cpu.battle.length;i++){
    const mon = cpu.battle[i];
    if(!mon) continue;
    if(mon.summonSick){ mon.summonSick = false; continue; } // cannot attack this turn, but remove sickness
    // if player has monsters, target weakest advantageous
    const playerTargets = match.player.battle.map((b,idx)=> b ? {b,idx} : null).filter(Boolean);
    if(playerTargets.length>0){
      // choose a target where mon.power >= target.power if possible
      let pick = playerTargets.find(pt => (mon.power||0) >= (pt.b.power||0));
      if(!pick) pick = playerTargets.reduce((acc,cur)=> (cur.b.power<acc.b.power?cur:acc), playerTargets[0]);
      // resolve
      const a = mon.power||0; const d = pick.b.power||0;
      if(a > d){ match.player.grave.push(pick.b); match.player.battle[pick.idx]=null; logMatch('CPUの'+mon.name+'が'+pick.b.name+'を破壊した'); }
      else if(a < d){ match.cpu.grave.push(mon); match.cpu.battle[i]=null; logMatch('CPUの'+mon.name+'は'+pick.b.name+'に敗れた'); }
      else { match.player.grave.push(pick.b); match.player.battle[pick.idx]=null; match.cpu.grave.push(mon); match.cpu.battle[i]=null; logMatch('CPUの'+mon.name+'と'+pick.b.name+'は互いに消滅した'); }
    } else {
      // attempt direct or damage shield
      if(match.player.shield === 0){
        alert('CPUがダイレクトアタックに成功しました。あなたの敗北です。');
        resetToMenu(); return;
      } else {
        match.player.shield = Math.max(0, match.player.shield - 1);
        logMatch('CPUの'+mon.name+'が攻撃し、あなたのシールドを1枚破壊した');
      }
    }
  }

  // Resolve CPU end-phase triggers
  resolveEndPhase('cpu');

  // switch back to player
  match.active = 'player';
  // advance round-related mana changes already handled in resolveEndPhase (we incremented turn)
  // Player start: draw and refill mana
  drawFor('player');
  updateAllUI();
  logMatch('---- あなたのターン開始 ----');
}

/* ========== helper functions when match inactive ========== */
function populateDecksOnStartup(){
  // ensure if no saved decks exist, create a default sample deck (auto fill with pool up to 50)
  if(savedDecks.length===0){
    // produce default deck: 50 by repeating base pool until 50, respecting 4 copies
    let poolIds = [];
    CARD_POOL.forEach(c=>{ for(let i=0;i<4;i++) poolIds.push(c.id); });
    shuffle(poolIds);
    const deck = poolIds.slice(0,50);
    const name = 'Default_AutoDeck';
    savedDecks.push({name, cards: deck});
    saveSavedDecks();
  }
  renderSavedDecksList();
}
function populateStartEditor(){
  // if currentBuild is empty, fill with a sample 50-card set (respect 4 copies)
  if(currentBuild.length===0){
    const pool = [];
    CARD_POOL.forEach(c=>{ for(let i=0;i<4;i++) pool.push(c.id); });
    shuffle(pool);
    currentBuild = pool.slice(0,50);
  }
  renderDeckList();
}

/* on load */
window.addEventListener('load', ()=>{
  populateDecksOnStartup();
  populateStartEditor();
  showView('viewMenu');
});

/* Small helpers for UI actions */
function populateDeckSelect(){
  // ensure options updated
  const sel = document.getElementById('deckSelect');
  sel.innerHTML = '';
  const none = document.createElement('option'); none.value='__none__'; none.textContent='-- 選択 --'; sel.appendChild(none);
  savedDecks.forEach(d=>{ const o = document.createElement('option'); o.value=d.name; o.textContent=d.name; sel.appendChild(o); });
}

/* reset everything from match (called on match end) */
function resetMatchState(){
  match=null;
  updateAllUI();
}

/* initial render of editor UI */
renderAllCards();
renderDeckList();
renderSavedDecksUI();
renderSavedDecksList();
</script>
</body>
</html>
