<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<title>ブラウザTCG - フルサンプル（パック+オンライン擬似）</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  body{font-family:system-ui,Arial;background:#f6f7fb;margin:12px;color:#111}
  h1{margin:0 0 12px}
  .row{display:flex;gap:12px;align-items:flex-start}
  .panel{background:#fff;border:1px solid #e0e0e0;border-radius:8px;padding:10px;box-shadow:0 1px 3px rgba(0,0,0,0.04)}
  .panel.small{width:260px}
  .card{display:inline-block;background:#fff;border:1px solid #bbb;border-radius:6px;padding:6px;margin:6px;width:120px;text-align:center;font-size:13px;cursor:pointer}
  .card.small{width:90px;padding:4px;font-size:12px}
  .btn{display:inline-block;padding:6px 10px;border-radius:6px;background:#fff;border:1px solid #333;cursor:pointer;margin:4px}
  .btn.primary{background:#111;color:#fff;border-color:#111}
  .muted{color:#666;font-size:13px}
  .fieldCardBox{background:#fff8dc;padding:8px;border-radius:6px;border:1px solid #d7c59a}
  .hand{min-height:80px}
  .zone{min-height:80px;padding:8px;border:1px dashed #ddd;border-radius:6px}
  input[type=text]{padding:6px;border-radius:6px;border:1px solid #ccc;width:220px}
  .deckRow{display:flex;gap:8px;align-items:center;margin:6px 0}
  #modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.5)}
  #modal .box{background:#fff;padding:18px;border-radius:8px;min-width:320px;text-align:center}
  .new{color:#c00;font-weight:700}
  .logArea{height:300px;overflow:auto;background:#fff;border:1px solid #ddd;padding:8px;border-radius:6px}
  .grid{display:grid;grid-template-columns:1fr 320px;gap:12px}
  .smallText{font-size:12px;color:#666}
  .disabled{opacity:0.5;pointer-events:none}
  .effectBtn{display:block;margin-top:6px;padding:4px 6px;border-radius:6px;border:1px solid #777;background:#f7f7f7;cursor:pointer}
  .effectBtn.disabled{opacity:0.5;pointer-events:none}
</style>
</head>
<body>

<h1>ブラウザTCG - 完全サンプル（オンライン擬似・パック）</h1>

<div id="menu" class="row" style="margin-bottom:12px">
  <div class="panel small">
    <div><strong>ユーザー:</strong> <span id="usernameDisplay">Guest</span></div>
    <div style="margin-top:6px"><strong>所持パック:</strong> <span id="packCount">0</span></div>
    <div><strong>欠片:</strong> <span id="shardCount">0</span>（10で1パック）</div>
    <div style="margin-top:8px">
      <button class="btn" onclick="openDeckBuilder()">デッキ構築</button>
      <button class="btn" onclick="openPackOpener()">パック開封</button>
      <button class="btn" onclick="openCollection()">所持カード</button>
    </div>
  </div>

  <div class="panel" style="flex:1">
    <div class="muted">ローカル保存（localStorage）でコレクション・デッキを管理します。オンライン戦は擬似マッチングです。</div>
    <div style="margin-top:8px">
      <button class="btn primary" onclick="startQuickCPUMatch()">CPU戦（ランダムデッキ）</button>
      <button class="btn" onclick="startOnlineMatch()">オンライン戦（擬似マッチング）</button>
      <button class="btn" onclick="claimDailyPacks()">デイリー2パック受取</button>
      <button class="btn" onclick="openSettings()">設定</button>
      <button class="btn" onclick="resetAll()">セーブ初期化</button>
    </div>
    <div style="margin-top:8px" class="smallText">※ CPU勝利ではパック獲得なし。オンライン勝利でパック+1（擬似）</div>
  </div>
</div>

<div id="mainArea" class="grid">
  <!-- left column: deck / pack / battle panels will be shown -->
  <div>
    <!-- デッキ構築 -->
    <div id="deckBuilder" class="panel" style="display:none;margin-bottom:12px">
      <h2>デッキ構築</h2>
      <div class="muted">デッキは30枚、同一カードは最大4枚まで。デッキに名前を付けて保存。</div>
      <div style="margin-top:8px">
        <strong>保存デッキ</strong>
        <div id="savedDecks" style="margin-top:8px"></div>
      </div>
      <hr>
      <div style="margin-top:8px">
        <strong>所持コレクション</strong>
        <div id="collectionArea" style="margin-top:8px"></div>
      </div>
      <div style="margin-top:8px">
        <strong>現在のデッキ（<span id="deckCount">0</span>/30）</strong>
        <div id="deckArea" style="margin-top:8px"></div>
        <div style="margin-top:8px">
          <input id="deckName" type="text" placeholder="デッキ名を入力（例: 初心者デッキ）"/>
          <button class="btn" onclick="saveCurrentDeck()">デッキ名を付けて保存</button>
          <button class="btn primary" onclick="saveDeckAndStart()">デッキ保存して開始</button>
          <button class="btn" onclick="closeDeckBuilder()">閉じる</button>
        </div>
      </div>
    </div>

    <!-- パック開封 -->
    <div id="packOpener" class="panel" style="display:none;margin-bottom:12px">
      <h2>パック開封</h2>
      <div>
        <button class="btn" onclick="openPackManual()">1パック開封</button>
        <button class="btn" id="exchangeBtn" onclick="exchangeShards()">欠片10個で1パック交換</button>
      </div>
      <div id="packResult" style="margin-top:12px"></div>
      <div style="margin-top:8px">
        <button class="btn" onclick="closePackOpener()">閉じる</button>
      </div>
      <div class="smallText" style="margin-top:8px">パックはオンライン勝利 / デイリー2パック / 初期10パックのみが基本入手源です（デバッグで配布可）。</div>
    </div>

    <!-- 所持カード -->
    <div id="collectionPanel" class="panel" style="display:none;margin-bottom:12px">
      <h2>所持カード（効果欄あり）</h2>
      <div id="collectionList"></div>
      <div style="margin-top:8px">
        <button class="btn" onclick="clearNewFlags()">NEWをクリア</button>
        <button class="btn" onclick="closeCollection()">閉じる</button>
      </div>
    </div>

    <!-- 対戦画面 -->
    <div id="battleArea" class="panel" style="display:none">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div>
          <strong id="playerNameLabel">あなた</strong> ライフ: <span id="playerLife">20</span> ｜ マナ: <span id="playerMana">0</span>/<span id="playerMaxMana">0</span>
        </div>
        <div>
          <button class="btn" onclick="surrender()">降参</button>
          <button class="btn" onclick="debugGivePack()">（デバッグ）1パック獲得</button>
        </div>
        <div>
          <strong id="opponentNameLabel">CPU</strong> ライフ: <span id="cpuLife">20</span> ｜ マナ: <span id="cpuMana">0</span>/<span id="cpuMaxMana">0</span>
        </div>
      </div>

      <div style="margin-top:8px" id="fieldCardArea">
        <div class="fieldCardBox" id="fieldCardBox">フィールド: なし</div>
        <div style="margin-top:6px" class="smallText">（フィールド効果は重ねず上書き：古いフィールドは墓地へ）</div>
      </div>

      <div style="margin-top:10px;display:flex;gap:12px">
        <div style="flex:1">
          <div><strong>CPU フィールド</strong></div>
          <div id="cpuField" class="zone cpu"></div>

          <div style="margin-top:10px"><strong>あなたのフィールド</strong></div>
          <div id="playerField" class="zone player"></div>

          <div style="margin-top:10px"><strong>あなたの手札</strong></div>
          <div id="playerHand" class="hand"></div>

          <div style="margin-top:10px">
            <button class="btn" onclick="endTurn()">ターン終了</button>
            <button class="btn primary" onclick="attackModeToggle()">攻撃モード</button>
            <button class="btn" onclick="toggleGrave()">墓地表示</button>
            <span class="muted" id="modeHint"></span>
          </div>
        </div>

        <div style="width:320px">
          <div class="panel" style="margin-bottom:8px">
            <h3>行動履歴</h3>
            <div id="actionLog" class="logArea"></div>
            <div style="margin-top:6px"><button class="btn" onclick="clearLog()">ログクリア</button></div>
          </div>

          <div class="panel">
            <h3>墓地（自分 / 相手）</h3>
            <div id="graveArea" style="min-height:80px;max-height:120px;overflow:auto"></div>
            <div style="margin-top:6px"><button class="btn" onclick="showFullGrave()">詳細表示</button></div>
          </div>
        </div>
      </div>
    </div>

  </div>

  <!-- right column: summary & settings -->
  <div>
    <div id="settingsPanel" class="panel" style="display:none;margin-bottom:12px">
      <h3>設定</h3>
      <div>
        <div>ユーザー名: <input id="usernameInput" type="text" placeholder="表示名を入力"/></div>
        <div style="margin-top:6px"><button class="btn" onclick="saveUsername()">保存</button></div>
      </div>
      <div style="margin-top:10px">
        <div class="muted">※オンライン戦は擬似マッチングです（ネット接続なし）。</div>
      </div>
      <div style="margin-top:8px"><button class="btn" onclick="closeSettings()">閉じる</button></div>
    </div>

    <div id="packSummary" class="panel" style="margin-bottom:12px">
      <h3>パック / 欠片</h3>
      <div>所持パック: <span id="packCount2">0</span></div>
      <div>欠片: <span id="shardCount2">0</span>（10で1パック）</div>
      <div style="margin-top:6px">
        <button class="btn" onclick="openPackOpener()">開封</button>
        <button class="btn" onclick="exchangeShards()">欠片を交換</button>
      </div>
    </div>

    <div class="panel" style="margin-bottom:12px">
      <h3>収録カード（サマリー）</h3>
      <div id="cardSummary" style="max-height:320px;overflow:auto"></div>
    </div>
  </div>
</div>

<!-- モーダル 共通 -->
<div id="modal">
  <div class="box" id="modalBox"></div>
</div>

<script>
/* ======================================================
   カード定義（日本語） — 各カードに rarity を追加
   rarity: "C","UC","R","RR","SR"
   All cards you defined (29) with rarities per your mapping
======================================================*/
const ALL_CARDS = [
  // monsters
  {id:"slime", name:"スライム", type:"monster", cost:1, atk:1, desc:"召喚時: デッキにスライムがいれば1枚手札に加える", rarity:"C"},
  {id:"kijin", name:"鬼人", type:"monster", cost:5, atk:4, desc:"エンド時: 相手場のランダムなモンスター1体（攻撃力≤鬼人ATK）を墓地へ", rarity:"C"},
  {id:"necromancer", name:"ネクロマンサー", type:"monster", cost:4, atk:2, desc:"エンド時: 自墓地からランダムでモンスター1体を召喚", rarity:"C"},
  {id:"jyujutsushi", name:"呪術師", type:"monster", cost:4, atk:2, desc:"場にいる間: 相手モンスターの効果無効化", rarity:"C"},
  {id:"golem", name:"ゴーレム", type:"monster", cost:3, atk:4, desc:"効果なし", rarity:"UC"},
  {id:"speedgolem", name:"スピードゴーレム", type:"monster", cost:5, atk:3, desc:"このモンスターは1ターンに2回攻撃できる", rarity:"R"},
  {id:"attackgolem", name:"アタックゴーレム", type:"monster", cost:5, atk:5, desc:"効果なし", rarity:"R"},
  {id:"ultgolem", name:"アルティメットゴーレム", type:"monster", cost:20, atk:6, desc:"特殊召喚専用: ゴーレム・スピードゴーレム・アタックゴーレムを生贄に特殊召喚。1ターンに2回攻撃", rarity:"SR"},
  {id:"ant", name:"アント", type:"monster", cost:1, atk:1, desc:"召喚時: デッキにアントαがいれば1枚手札に加える", rarity:"UC"},
  {id:"ant_a", name:"アントα", type:"monster", cost:1, atk:1, desc:"召喚時: デッキからカード名に『アント』を含むカードを1枚手札に加える", rarity:"UC"},
  {id:"ironant", name:"アイアンアント", type:"monster", cost:2, atk:3, desc:"効果なし", rarity:"R"},
  {id:"goldant", name:"ゴールドアント", type:"monster", cost:3, atk:3, desc:"起動効果(1ターン1回): デッキからアント/アントαを選んで場に出す（召喚酔いなし）", rarity:"RR"},
  {id:"antking", name:"アントキング", type:"monster", cost:4, atk:4, desc:"起動効果(1ターン1回): 墓地からアント名のカードを最大2体選び場に召喚（酔いなし）", rarity:"SR"},
  // spells
  {id:"heal", name:"ヒーリングライト", type:"spell", cost:2, desc:"自分のライフを3回復", rarity:"C"},
  {id:"sacrifice", name:"ダークサクリファイス", type:"spell", cost:3, desc:"自分のモンスター1体を破壊して、そのATK分相手にダメージ", rarity:"C"},
  {id:"thunder", name:"雷撃", type:"spell", cost:4, desc:"相手に2ダメージ", rarity:"C"},
  {id:"relic", name:"亡者の遺品", type:"spell", cost:2, desc:"自分の墓地のカード1枚を手札に戻す", rarity:"C"},
  {id:"ant_egg", name:"アントの卵", type:"spell", cost:2, desc:"山札からアント名のカードを最大2枚まで手札に加え、デッキをシャッフルする", rarity:"UC"},
  {id:"ant_rage", name:"アントの逆襲", type:"spell", cost:2, desc:"このターン、自分のアント名のモンスターのATKを+1する（ターン終了まで）", rarity:"UC"},
  {id:"ant_grow", name:"アントの育成", type:"spell", cost:2, desc:"このターン、自分のアント名のモンスターのコストを-1する（最低0）", rarity:"UC"},
  {id:"ant_awake", name:"アントの覚醒", type:"spell", cost:1, desc:"自分の場のアント名のモンスターの召喚酔いを解除する", rarity:"UC"},
  {id:"snipe", name:"狙い撃ち", type:"spell", cost:4, desc:"相手の攻撃力4以下のモンスターを1体墓地に送る（相手限定）", rarity:"R"},
  {id:"research", name:"博士の研究", type:"spell", cost:1, desc:"2枚ドロー。このカードは1ターンに1回のみ使用可", rarity:"C"},
  {id:"magic_search", name:"マジックサーチ", type:"spell", cost:2, desc:"山札から魔法カードを1枚選んで手札に加える（非公開）", rarity:"C"},
  {id:"monster_search", name:"モンスターサーチ", type:"spell", cost:2, desc:"山札からモンスターカードを1枚選んで手札に加える（非公開）", rarity:"C"},
  // fields
  {id:"happy", name:"ハッピーマウンテン", type:"field", cost:2, desc:"エンド時: 両者1ドロー", rarity:"C"},
  {id:"forest", name:"亡者の森", type:"field", cost:3, desc:"エンド時: ランダムな墓地のカード1枚を持ち主の手札へ", rarity:"R"},
  {id:"ant_nest", name:"アントの巣", type:"field", cost:2, desc:"アント名のモンスターの攻撃力を常時+1（全体）", rarity:"R"},
  {id:"ant_spawn", name:"アントの産卵場", type:"field", cost:3, desc:"場にある間、両者のアント名モンスターの召喚コストを-1する（最低0）", rarity:"R"}
];

/* ======================================================
   パック排出確率（定数）
   C:60%, UC:25%, R:10%, RR:4%, SR:1%
======================================================*/
const RARITY_WEIGHTS = [
  {r:"C", w:60},
  {r:"UC", w:25},
  {r:"R", w:10},
  {r:"RR", w:4},
  {r:"SR", w:1}
];

/* ======================================================
   localStorage keys & state variables
======================================================*/
const KEY_COLLECTION = "tcg_collection_full_v1";
const KEY_PACKS = "tcg_packs_full_v1";
const KEY_SHARDS = "tcg_shards_full_v1";
const KEY_DECKS = "tcg_decks_full_v1";
const KEY_NEW = "tcg_new_full_v1";
const KEY_USERNAME = "tcg_user_full_v1";
const KEY_LASTDAILY = "tcg_lastdaily_v1";

let collection = {}; // {id:count}
let packCount = 0;
let shardCount = 0;
let savedDecks = {}; // {name: [ids]}
let newCards = {}; // {id:true}
let username = "Guest";
let lastDaily = null;

/* ======================================================
   マッチ / ゲーム状態
======================================================*/
let currentDeck = []; // builder working deck
let player = null, opponent = null;
let globalField = null;
let playerTurn = true;
let attackMode = false;
let selectedAttacker = null;
let gameActive = false;
let actionLog = []; // log entries

/* ======================================================
   ヘルパー関数: load/save
======================================================*/
function loadAll(){
  collection = JSON.parse(localStorage.getItem(KEY_COLLECTION) || "{}");
  packCount = parseInt(localStorage.getItem(KEY_PACKS) || "0");
  shardCount = parseInt(localStorage.getItem(KEY_SHARDS) || "0");
  savedDecks = JSON.parse(localStorage.getItem(KEY_DECKS) || "{}");
  newCards = JSON.parse(localStorage.getItem(KEY_NEW) || "{}");
  username = localStorage.getItem(KEY_USERNAME) || "Guest";
  lastDaily = localStorage.getItem(KEY_LASTDAILY) || null;
}
function saveAll(){
  localStorage.setItem(KEY_COLLECTION, JSON.stringify(collection));
  localStorage.setItem(KEY_PACKS, String(packCount));
  localStorage.setItem(KEY_SHARDS, String(shardCount));
  localStorage.setItem(KEY_DECKS, JSON.stringify(savedDecks));
  localStorage.setItem(KEY_NEW, JSON.stringify(newCards));
  localStorage.setItem(KEY_USERNAME, username);
  if(lastDaily) localStorage.setItem(KEY_LASTDAILY, lastDaily);
}

/* ======================================================
   初回: 初期10パック配布（自動開封、NEW登録）
   — ただし以降のパック獲得は規定の手段のみ
======================================================*/
function ensureInitial(){
  loadAll();
  if(Object.keys(collection).length === 0 && packCount === 0 && shardCount === 0){
    // auto open 10 packs silently to give initial cards
    for(let i=0;i<10;i++){ openPackInternal(true); }
    packCount = 0; // consume initial allotment into collection
    saveAll();
    alert("初期10パックを配布しました（コレクションに自動追加）");
  }
  updateTopCounts();
}

/* ======================================================
   レアリティ -> カード抽選
======================================================*/
function pickRarity(){
  const total = RARITY_WEIGHTS.reduce((s,x)=>s+x.w,0);
  let r = Math.random()*total;
  for(const rw of RARITY_WEIGHTS){
    if(r < rw.w) return rw.r;
    r -= rw.w;
  }
  return "C";
}
function pickCardByRarity(r){
  const pool = ALL_CARDS.filter(c=>c.rarity === r);
  if(pool.length === 0) return ALL_CARDS[Math.floor(Math.random()*ALL_CARDS.length)];
  return pool[Math.floor(Math.random()*pool.length)];
}

/* ======================================================
   コレクション管理（4枚目以降をシャード化）
======================================================*/
function addCardToCollection(id){
  const owned = collection[id] || 0;
  if(owned < 4){
    collection[id] = owned + 1;
    newCards[id] = true;
    saveAll();
    return {isNew:owned===0, shardGained:false};
  } else {
    shardCount++;
    saveAll();
    updateTopCounts();
    return {isNew:false, shardGained:true};
  }
}

/* ======================================================
   パック開封（1パック=5枚）
   - openPackInternal(silent): returns array of results
   - openPackManual: consumes packCount
======================================================*/
function openPackInternal(silent=false){
  const res = [];
  for(let i=0;i<5;i++){
    const r = pickRarity();
    const card = pickCardByRarity(r);
    const add = addCardToCollection(card.id);
    res.push({card, rarity:r, isNew:add.isNew, shardGained:add.shardGained});
  }
  if(!silent) showPackResultOnPage(res);
  updateTopCounts(); saveAll();
  return res;
}
function openPackManual(){
  if(packCount <= 0){ alert("パックがありません"); return; }
  packCount--; saveAll(); updateTopCounts();
  const res = openPackInternal(false);
  showPackResultOnPage(res);
}

/* shards -> pack exchange (10 shards now) */
function exchangeShards(){
  if(shardCount < 10){ alert("欠片が10個必要です"); return; }
  shardCount -= 10; packCount++; saveAll(); updateTopCounts();
  alert("欠片10個で1パックを獲得しました");
}

/* ======================================================
   UI: pack result
======================================================*/
function showPackResultOnPage(results){
  const area = document.getElementById("packResult"); area.innerHTML = "<h3>開封結果</h3>";
  results.forEach(r=>{
    const div = document.createElement("div"); div.className="card small";
    div.innerHTML = `${r.card.name} <div class="smallText">${r.rarity}</div> ${r.isNew?'<div class="new">NEW!</div>':''}${r.shardGained?'<div class="smallText">（欠片+1）</div>':''}`;
    area.appendChild(div);
  });
}

/* ======================================================
   UI更新 top counts / summary
======================================================*/
function updateTopCounts(){
  document.getElementById("packCount").textContent = packCount;
  document.getElementById("shardCount").textContent = shardCount;
  document.getElementById("packCount2").textContent = packCount;
  document.getElementById("shardCount2").textContent = shardCount;
  document.getElementById("usernameDisplay").textContent = username || "Guest";
  document.getElementById("exchangeBtn").disabled = (shardCount < 10);
  renderCardSummary();
}

/* ======================================================
   カードサマリ表示
======================================================*/
function renderCardSummary(){
  const el = document.getElementById("cardSummary"); el.innerHTML = "";
  ALL_CARDS.forEach(c=>{
    const owned = collection[c.id] || 0;
    const d = document.createElement("div"); d.className="smallText";
    d.innerHTML = `<strong>${c.name}</strong> [${c.rarity}] - ${c.type} / cost:${c.cost||"-"} / atk:${c.atk||"-"} <div class="muted">${c.desc}</div><div>所持:${owned}${newCards[c.id?c.id:'']? ' <span class="new">NEW</span>':''}</div>`;
    el.appendChild(d);
  });
}

/* ======================================================
   デッキ構築：render collection & deck
======================================================*/
function openDeckBuilder(){
  loadAll();
  document.getElementById("menu").style.display = "none";
  document.getElementById("packOpener").style.display = "none";
  document.getElementById("collectionPanel").style.display = "none";
  document.getElementById("deckBuilder").style.display = "block";
  renderSavedDecks(); renderCollectionArea(); renderDeckArea(); updateTopCounts();
}
function closeDeckBuilder(){
  document.getElementById("deckBuilder").style.display = "none"; document.getElementById("menu").style.display = "flex";
}
function renderSavedDecks(){
  const area = document.getElementById("savedDecks"); area.innerHTML = "";
  for(const name in savedDecks){
    const row = document.createElement("div"); row.className="deckRow";
    const span = document.createElement("div"); span.style.flex="1"; span.textContent = `${name} (${savedDecks[name].length}枚)`;
    const loadBtn = document.createElement("button"); loadBtn.className="btn"; loadBtn.textContent="読み込み";
    loadBtn.onclick = ()=>{ currentDeck = savedDecks[name].slice(); renderCollectionArea(); renderDeckArea(); };
    const delBtn = document.createElement("button"); delBtn.className="btn"; delBtn.textContent="削除";
    delBtn.onclick = ()=>{ if(confirm(`${name} を削除しますか？`)){ delete savedDecks[name]; saveAll(); renderSavedDecks(); } };
    row.appendChild(span); row.appendChild(loadBtn); row.appendChild(delBtn);
    area.appendChild(row);
  }
}
function renderCollectionArea(){
  const area = document.getElementById("collectionArea"); area.innerHTML = "";
  ALL_CARDS.forEach(c=>{
    const owned = collection[c.id] || 0; const inDeck = currentDeck.filter(x=>x===c.id).length;
    const d = document.createElement("div"); d.className="card";
    d.innerHTML = `<strong>${c.name}</strong><div class="muted">${c.type} / cost:${c.cost||"-"}</div><div>所持:${owned} / デッキ:${inDeck}</div>${newCards[c.id]? '<div class="new">NEW</div>':''}`;
    d.onclick = ()=>{
      if(currentDeck.length >= 30){ alert("デッキは30枚までです"); return; }
      if(inDeck >= 4){ alert("同じカードは4枚までです"); return; }
      if(inDeck >= owned){ alert("所持枚数を超えています"); return; }
      currentDeck.push(c.id); renderCollectionArea(); renderDeckArea();
    };
    area.appendChild(d);
  });
}
function renderDeckArea(){
  const area = document.getElementById("deckArea"); area.innerHTML = "";
  currentDeck.forEach((id, idx)=>{
    const c = ALL_CARDS.find(x=>x.id===id);
    const d = document.createElement("div"); d.className="card";
    d.innerHTML = `${c.name}<div class="muted">クリックでデッキから戻す</div>`;
    d.onclick = ()=>{ // 戻す：デッキ->所持に1枚戻す（超過は欠片化）
      const owned = collection[id] || 0;
      if(owned >= 4){
        shardCount++; alert('所持が4枚以上のため戻したカードは欠片に変換されました（欠片+1）');
      } else {
        collection[id] = owned + 1;
      }
      currentDeck.splice(idx,1); saveAll(); renderCollectionArea(); renderDeckArea(); updateTopCounts();
    };
    area.appendChild(d);
  });
  document.getElementById("deckCount").textContent = currentDeck.length;
}
function saveCurrentDeck(){
  const name = document.getElementById("deckName").value.trim();
  if(!name){ alert("デッキ名を入力してください"); return; }
  if(currentDeck.length !== 30){ alert("デッキはちょうど30枚必要です"); return; }
  savedDecks[name] = currentDeck.slice(); saveAll(); renderSavedDecks(); alert("デッキを保存しました: " + name);
}
function saveDeckAndStart(){ if(currentDeck.length !== 30){ alert("デッキはちょうど30枚必要です"); return;} saveAll(); startMatchWithDeck(currentDeck); }

/* ======================================================
   所持カード画面
======================================================*/
function openCollection(){
  loadAll();
  document.getElementById("menu").style.display = "none";
  document.getElementById("collectionPanel").style.display = "block";
  renderCollectionList();
}
function closeCollection(){ document.getElementById("collectionPanel").style.display="none"; document.getElementById("menu").style.display="flex"; }
function renderCollectionList(){
  const area = document.getElementById("collectionList"); area.innerHTML="";
  ALL_CARDS.forEach(c=>{
    const owned = collection[c.id] || 0;
    const d = document.createElement("div"); d.className="card small";
    d.innerHTML = `<strong>${c.name}</strong><div class="muted">${c.type} / cost:${c.cost||"-"}</div><div>${c.desc}</div><div>所持:${owned} ${newCards[c.id]?'<span class="new">NEW</span>':''}</div>`;
    area.appendChild(d);
  });
}
function clearNewFlags(){ newCards = {}; saveAll(); renderCollectionList(); alert('NEWフラグをクリアしました'); }

/* ======================================================
   対戦ロジック（簡略化/体系化）
   - マナ: startTurn increments maxMana (cap10) and sets currMana=maxMana
   - 先行の1ターン目はモンスター召喚禁止（flag: player.turnCount）
   - 行動ログ: logAction(text)
======================================================*/
function startMatchWithDeck(deckList, isOnline=false, oppName="CPU"){
  player = {name:username || "Guest", life:20, deck:deckList.map(id=>({id, uid:Math.random()})), hand:[], field:[], grave:[], maxMana:0, currMana:0, turnCount:0, antCostReduction:0, usedResearch:false};
  opponent = {name: isOnline ? oppName : "CPU", life:20, deck:deckList.map(id=>({id, uid:Math.random()})), hand:[], field:[], grave:[], maxMana:0, currMana:0, turnCount:0, antCostReduction:0, usedResearch:false};
  shuffle(player.deck); shuffle(opponent.deck);
  player.hand = []; opponent.hand = [];
  for(let i=0;i<5;i++){ draw(player); draw(opponent); }
  globalField = null; playerTurn = Math.random() < 0.5; attackMode=false; selectedAttacker=null; gameActive=true;
  document.getElementById("menu").style.display="none"; document.getElementById("deckBuilder").style.display="none"; document.getElementById("packOpener").style.display="none"; document.getElementById("collectionPanel").style.display="none"; document.getElementById("battleArea").style.display="block";
  actionLog=[]; renderLog(); logAction(`対戦開始: あなた(${player.name}) vs ${opponent.name}（${isOnline? "オンライン":"CPU"}）`); 
  // Start: assign mana to starting player? We'll set both 0 and then call startTurn on the current player
  if(playerTurn){ logAction("あなたが先行です（先行の1ターン目はモンスターを出せません）"); } else { logAction("あなたは後攻です"); }
  startTurnFor(playerTurn ? player : opponent);
  renderBattle();
}

function startQuickCPUMatch(){
  // build deck from collection or fill with slimes
  if(Object.keys(collection).length===0) ensureInitial();
  const deck = [];
  for(const c of ALL_CARDS){
    const own = collection[c.id] || 0; const add = Math.min(4, own);
    for(let i=0;i<add && deck.length<30;i++) deck.push(c.id);
  }
  while(deck.length<30) deck.push("slime");
  currentDeck = deck.slice();
  startMatchWithDeck(currentDeck, false, "CPU");
}

function startOnlineMatch(){
  // require username set
  if(!username || username.trim()===""){ alert("設定でユーザー名を入力してください"); openSettings(); return; }
  // simulate matchmaking
  showModal(`<h3>オンラインマッチング中...</h3><div class="muted">マッチング中 — 数秒で対戦を開始します（擬似）</div>`, false);
  setTimeout(()=>{ 
    closeModal();
    // create fake opponent name
    const oppName = "Player_" + Math.floor(Math.random()*9000+1000);
    // show matched and start
    alert("マッチング成功: 対戦相手 " + oppName + " とマッチングしました");
    // build deck for opponent (simple)
    const deck = [];
    for(const c of ALL_CARDS){
      const add = Math.min(2, 2); // simple
      for(let i=0;i<add && deck.length<30;i++) deck.push(c.id);
    }
    while(deck.length<30) deck.push("slime");
    startMatchWithDeck(deck, true, oppName);
  }, 1200 + Math.random()*1800);
}

/* draw / shuffle */
function draw(side){
  if(side.deck.length===0) return;
  const card = side.deck.pop();
  const data = ALL_CARDS.find(x=>x.id===card.id);
  side.hand.push({ uid:card.uid, id:data.id, name:data.name, type:data.type, cost:data.cost||0, atk:data.atk||0, desc:data.desc||"" });
}
function shuffle(a){ for(let i=a.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [a[i],a[j]]=[a[j],a[i]]; } }

/* startTurn for a side */
function startTurnFor(side){
  side.turnCount = (side.turnCount||0) + 1;
  side.maxMana = Math.min((side.maxMana||0) + 1, 10);
  side.currMana = side.maxMana;
  // reset per-card usedEffectThisTurn flags
  side.field.forEach(c=>{ c.usedEffectThisTurn = false; if(c.id==="speedgolem"){ c.extraAttacksRemaining = (c.extraAttacksRemaining===undefined)?1:c.extraAttacksRemaining; } });
  // reset per-player one-use flags
  side.usedResearch = false;
  logAction(`${side === player ? "あなた" : opponent.name} のターン開始（ターン ${side.turnCount}）`);
  // if this is the first turn and player went first, disallow monster summons for that player's first turn:
  if(side === player && playerTurn && player.turnCount === 1){
    logAction("あなたは先行のため、このターンはモンスターを召喚できません（先行1ターン目ルール）");
  }
}

/* ======================================================
   Rendering battle / UI functions
======================================================*/
function renderBattle(){
  if(!player || !opponent) return;
  document.getElementById("playerLife").textContent = player.life;
  document.getElementById("cpuLife").textContent = opponent.life;
  document.getElementById("playerMana").textContent = player.currMana;
  document.getElementById("playerMaxMana").textContent = player.maxMana;
  document.getElementById("cpuMana").textContent = opponent.currMana;
  document.getElementById("playerNameLabel").textContent = player.name;
  document.getElementById("opponentNameLabel").textContent = opponent.name;

  document.getElementById("fieldCardBox").innerHTML = globalField ? `<strong>フィールド:</strong> ${globalField.name}<div class="muted">${globalField.desc}</div>` : "フィールド: なし";

  const cpuF = document.getElementById("cpuField"); cpuF.innerHTML="";
  opponent.field.forEach((c, idx)=>{
    const d = document.createElement("div"); d.className="card small";
    d.innerHTML = `${c.name}<br>ATK:${getCardAtk(c, opponent)}`;
    cpuF.appendChild(d);
  });

  const plF = document.getElementById("playerField"); plF.innerHTML="";
  player.field.forEach((c, idx)=>{
    const d = document.createElement("div"); d.className="card";
    // show effect buttons for GoldAnt / AntKing etc.
    let inner = `${c.name}<br>ATK:${getCardAtk(c, player)}`;
    if(c.canAttack && !c.hasAttacked && playerTurn){
      inner += `<br><button class="btn" onclick="playerAttackAction(${idx})">攻撃</button>`;
    } else {
      if(!c.canAttack) inner += `<div class="muted">(召喚酔い)</div>`;
      if(c.hasAttacked) inner += `<div class="muted">(攻撃済)</div>`;
    }
    // GoldAnt effect button
    if(c.id === "goldant"){
      const btnId = `gold-btn-${c.uid}`;
      inner += `<br><button id="${btnId}" class="effectBtn" onclick="activateGoldAnt('${c.uid}')">効果発動</button>`;
    }
    if(c.id === "antking"){
      const btnId = `king-btn-${c.uid}`;
      inner += `<br><button id="${btnId}" class="effectBtn" onclick="activateAntKing('${c.uid}')">効果発動</button>`;
    }
    d.innerHTML = inner;
    plF.appendChild(d);
    // update effect buttons enable/disable
    setTimeout(()=>{ updatePerCardEffectButtons(c, player); },0);
  });

  const ph = document.getElementById("playerHand"); ph.innerHTML="";
  player.hand.forEach((c, idx)=>{
    const d = document.createElement("div"); d.className="card";
    d.innerHTML = `<strong>${c.name}</strong><div class="muted">${c.type} / cost:${getCardCostFor(c, player)}</div><div style="font-size:12px">${c.desc||""}</div>`;
    d.onclick = ()=>{ playCardFromHand(idx); };
    ph.appendChild(d);
  });

  document.getElementById("modeHint").textContent = attackMode ? "攻撃モード: 相手モンスターをクリック（相手場が空なら直接攻撃ボタン）" : "";
  // update grave display
  renderGraveArea();
  checkWinSilent();
}

/* calculate effective attack including buffs (temp and field) */
function getCardAtk(card, owner){
  let atk = card.atk || 0;
  if(card.tempBuff) atk += card.tempBuff;
  // field: ant_nest gives +1 to names containing 'アント'
  if(globalField && globalField.id === "ant_nest" && card.name.includes("アント")){
    atk += 1;
  }
  return atk;
}

/* calculate card cost with ant spawn & player reductions */
function getCardCostFor(cardObj, side){
  let baseCost = cardObj.cost || 0;
  // ant育成 temporary reduction
  if(cardObj.name && cardObj.name.includes("アント") && side.antCostReduction){
    baseCost = Math.max(0, baseCost - side.antCostReduction);
  }
  // field effect: ant_spawn reduces cost by 1 for both players
  if(globalField && globalField.id === "ant_spawn" && cardObj.name && cardObj.name.includes("アント")){
    baseCost = Math.max(0, baseCost - 1);
  }
  return baseCost;
}

/* ======================================================
   play card from hand (player only)
   - check mana, type: monster/spell/field
   - first-turn-prevent monsters if starting player and turnCount===1
======================================================*/
function playCardFromHand(idx){
  if(!playerTurn){ alert("自分のターンではありません"); return; }
  const card = player.hand[idx];
  const cost = getCardCostFor(card, player);
  // check first-turn restriction: if player is starting player and player.turnCount===1 cannot summon monsters
  if(card.type === "monster" && player.turnCount === 1 && player.maxMana === player.currMana && player.maxMana===1 && playerTurn && player.turnCount===1){
    // This heuristic might be weak; instead check initially who was first: we set playerTurn initially
  }
  // simplified: if player.turnCount===1 AND player is the one who started first AND player was first -> block monster
  if(card.type === "monster" && player.turnCount === 1 && player === (playerTurn ? player : null) && playerStartedFirst()){
    alert("先行1ターン目はモンスターを召喚できません");
    return;
  }

  if(player.currMana < cost){ alert("マナが足りません"); return; }
  player.currMana -= cost;

  if(card.type === "monster"){
    // normal summon
    player.field.push({ uid:card.uid, id:card.id, name:card.name, atk:card.atk, canAttack:false, hasAttacked:false, usedEffectThisTurn:false });
    logAction(`あなたはモンスター「${card.name}」を召喚した`);
    // summon effects
    if(card.id === "slime"){
      const sIdx = player.deck.findIndex(x=>x.id==="slime");
      if(sIdx >= 0){
        const cc = player.deck.splice(sIdx,1)[0]; const data = ALL_CARDS.find(x=>x.id===cc.id);
        player.hand.push({ uid:cc.uid, id:data.id, name:data.name, type:data.type, cost:data.cost||0, atk:data.atk||0, desc:data.desc||"" });
        logAction("スライムの効果でデッキからスライムを手札に加えた");
      }
    }
    // ant / ant_a summon effects: handled by their desc? ant and ant_a effects are "on summon search" — implement:
    if(card.id === "ant"){
      const idx = player.deck.findIndex(x=>x.id==="ant_a");
      if(idx>=0){ const cc=player.deck.splice(idx,1)[0]; const data=ALL_CARDS.find(x=>x.id===cc.id); player.hand.push({uid:cc.uid,id:data.id,name:data.name,type:data.type,cost:data.cost||0,atk:data.atk||0,desc:data.desc||""}); logAction("アントの効果でアントαを手札に加えた"); }
    }
    if(card.id === "ant_a"){
      // search deck for any card name includes 'アント'
      const idx = player.deck.findIndex(x=> ALL_CARDS.find(c=>c.id===x.id).name.includes("アント") );
      if(idx>=0){ const cc=player.deck.splice(idx,1)[0]; const data=ALL_CARDS.find(x=>x.id===cc.id); player.hand.push({uid:cc.uid,id:data.id,name:data.name,type:data.type,cost:data.cost||0,atk:data.atk||0,desc:data.desc||""}); logAction("アントαの効果でデッキからアント系を手札に加えた"); }
    }
  } else if(card.type === "spell"){
    resolveSpell(card, true);
    logAction(`あなたは魔法「${card.name}」を発動した`);
    player.grave.push({id:card.id, name:card.name});
  } else if(card.type === "field"){
    if(globalField) player.grave.push({id:globalField.id, name:globalField.name});
    globalField = {id:card.id, name:card.name, desc:card.desc};
    logAction(`フィールド「${card.name}」を発動し、場が上書きされた`);
  }
  player.hand.splice(idx,1); renderBattle();
}

/* helper to detect if player was starter (first to move) */
function playerStartedFirst(){
  // Simplify: when match started, playerTurn indicated who is to start; if playerTurn true at match start then player started first.
  // We can store a variable but for simplicity assume player turn alternates and we tested earlier: store global initialStarter
  return initialStarter === "player";
}
let initialStarter = null;

/* resolve spell (player or cpu) */
function resolveSpell(card, isPlayer){
  const me = isPlayer ? player : opponent;
  const opp = isPlayer ? opponent : player;
  if(card.id === "heal"){ me.life += 3; logAction(`${isPlayer? "あなた" : opp.name} のライフが3回復`); }
  if(card.id === "sacrifice"){
    if(me.field.length>0){
      const m = me.field.pop(); me.grave.push({id:m.id,name:m.name}); opp.life -= m.atk;
      logAction(`${isPlayer? "あなた" : "相手"} は ${m.name} を破壊し、${m.atk}ダメージを与えた`);
    }
  }
  if(card.id === "thunder"){ opp.life -= 2; logAction(`${isPlayer? "あなた" : "相手"} は雷撃で相手に2ダメージ`); }
  if(card.id === "relic"){
    if(me.grave.length>0){
      const idx = Math.floor(Math.random()*me.grave.length); const g = me.grave.splice(idx,1)[0];
      const data = ALL_CARDS.find(x=>x.id===g.id);
      me.hand.push({uid:Math.random(), id:data.id, name:data.name, type:data.type, cost:data.cost||0, atk:data.atk||0, desc:data.desc||""});
      logAction(`${isPlayer? "あなた" : "相手"} は亡者の遺品で墓地から ${data.name} を手札に加えた`);
    }
  }
  if(card.id === "ant_egg"){
    // search deck for ant-named
    const choices = player.deck.filter(x=> ALL_CARDS.find(c=>c.id===x.id).name.includes("アント"));
    if(choices.length === 0){ logAction("デッキにアント系がいない"); return; }
    showSelectionModal("アントの卵：山札から選択（最大2）", choices.map(x=>ALL_CARDS.find(c=>c.id===x.id)), 2, (selected)=>{
      // remove selected from deck and add to hand
      selected.forEach(sel=>{
        // find one instance in deck
        const idx = player.deck.findIndex(x=>x.id===sel.id);
        if(idx>=0){ const cc = player.deck.splice(idx,1)[0]; const data = ALL_CARDS.find(c=>c.id===cc.id); player.hand.push({uid:cc.uid,id:data.id,name:data.name,type:data.type,cost:data.cost||0,atk:data.atk||0,desc:data.desc||""}); }
      });
      shuffle(player.deck); logAction("アントの卵でカードを手札に加え、デッキをシャッフルした");
      renderBattle();
    });
    return; // handled with modal
  }
  if(card.id === "ant_rage"){
    // apply temp buff to player's ant cards this turn
    player.field.forEach(c=>{ if(c.name.includes("アント")){ c.tempBuff = (c.tempBuff||0) + 1; } });
    logAction("アントの逆襲で自分のアント系のATKをターン終了まで+1した");
  }
  if(card.id === "ant_grow"){
    player.antCostReduction = 1;
    logAction("アントの育成でこのターン、アント系のコストが-1される");
  }
  if(card.id === "ant_awake"){
    player.field.forEach(c=>{ if(c.name.includes("アント")){ c.canAttack = true; } });
    logAction("アントの覚醒で自分のアントの召喚酔いを解除した");
  }
  if(card.id === "snipe"){
    // select target from opponent.field with atk <= 4 (consider buffs)
    const targets = opponent.field.filter(m=> getCardAtk(m, opponent) <= 4);
    if(targets.length === 0){ logAction("狙い撃ちの対象がいない"); return; }
    showSelectionModal("狙い撃ち: 対象を選択", targets, 1, (sel)=>{ // sel is array
      const target = sel[0];
      const idx = opponent.field.indexOf(target);
      if(idx>=0){ opponent.grave.push({id:target.id,name:target.name}); opponent.field.splice(idx,1); logAction(`狙い撃ちで相手の${target.name}を墓地に送った`); }
      renderBattle();
    });
    return;
  }
  if(card.id === "research"){
    // one-use per-turn
    if(me.usedResearch){ alert("博士の研究はこのターン既に使われています"); return; }
    draw(me); draw(me); me.usedResearch = true; logAction(`${isPlayer? "あなた" : "相手"} は博士の研究で2枚ドローした`);
  }
  if(card.id === "magic_search"){
    const spells = me.deck.filter(x=> ALL_CARDS.find(c=>c.id===x.id).type === "spell");
    if(spells.length === 0){ logAction("山札に魔法カードがない"); return; }
    showSelectionModal("マジックサーチ: 魔法を1枚選択", spells.map(x=>ALL_CARDS.find(c=>c.id===x.id)), 1, (sel)=>{
      const s = sel[0]; const idx = me.deck.findIndex(x=>x.id===s.id);
      if(idx>=0){ const cc = me.deck.splice(idx,1)[0]; const data = ALL_CARDS.find(c=>c.id===cc.id); me.hand.push({uid:cc.uid,id:data.id,name:data.name,type:data.type,cost:data.cost||0,atk:data.atk||0,desc:data.desc||""}); shuffle(me.deck); logAction("マジックサーチで魔法を手札に加えた"); renderBattle(); }
    });
    return;
  }
  if(card.id === "monster_search"){
    const mons = me.deck.filter(x=> ALL_CARDS.find(c=>c.id===x.id).type === "monster");
    if(mons.length === 0){ logAction("山札にモンスターがない"); return; }
    showSelectionModal("モンスターサーチ: モンスターを1枚選択", mons.map(x=>ALL_CARDS.find(c=>c.id===x.id)), 1, (sel)=>{
      const s = sel[0]; const idx = me.deck.findIndex(x=>x.id===s.id);
      if(idx>=0){ const cc = me.deck.splice(idx,1)[0]; const data = ALL_CARDS.find(c=>c.id===cc.id); me.hand.push({uid:cc.uid,id:data.id,name:data.name,type:data.type,cost:data.cost||0,atk:data.atk||0,desc:data.desc||""}); shuffle(me.deck); logAction("モンスターサーチでモンスターを手札に加えた"); renderBattle(); }
    });
    return;
  }
  renderBattle();
}

/* ======================================================
   攻撃処理（プレイヤー操作）
   - playerAttackAction(idx) shows options: if opponent.field length>0 -> attack target selection; else direct attack
======================================================*/
function playerAttackAction(attIdx){
  const attacker = player.field[attIdx];
  if(!attacker || !attacker.canAttack || attacker.hasAttacked){ alert("攻撃できません"); return; }
  if(opponent.field.length > 0){
    attackMode = true; selectedAttacker = attacker; renderBattle();
  } else {
    // direct attack
    opponent.life -= getCardAtk(attacker, player); attacker.hasAttacked = true; logAction(`あなたの${attacker.name}が直接攻撃し、相手に${getCardAtk(attacker, player)}ダメージ`); checkWin(); renderBattle();
  }
}

/* when attackMode and player clicks opponent card */
function playerAttackTarget(attacker, targetIdx){
  const defender = opponent.field[targetIdx];
  if(!attacker || !defender) { attackMode=false; selectedAttacker=null; renderBattle(); return; }
  // battle resolution
  const aAtk = getCardAtk(attacker, player); const dAtk = getCardAtk(defender, opponent);
  if(aAtk > dAtk){ opponent.grave.push({id:defender.id,name:defender.name}); opponent.field.splice(targetIdx,1); logAction(`${attacker.name}は${defender.name}を破壊した`); }
  else if(aAtk < dAtk){ player.grave.push({id:attacker.id,name:attacker.name}); const aIdx = player.field.indexOf(attacker); if(aIdx>=0) player.field.splice(aIdx,1); logAction(`${attacker.name}は${defender.name}に敗れ破壊された`); }
  else { opponent.grave.push({id:defender.id,name:defender.name}); player.grave.push({id:attacker.id,name:attacker.name}); opponent.field.splice(targetIdx,1); const aIdx = player.field.indexOf(attacker); if(aIdx>=0) player.field.splice(aIdx,1); logAction(`${attacker.name} と ${defender.name} は同値で両方破壊された`); }
  attacker.hasAttacked = true;
  attackMode=false; selectedAttacker=null;
  checkWin(); renderBattle();
}

/* Called by clicking cpu target in rendering */
function playerAttackTargetByIndex(attIdx, targetIdx){
  const attacker = player.field[attIdx]; playerAttackTarget(attacker, targetIdx);
}

/* ======================================================
   CPU turn & logic (simple)
======================================================*/
function cpuTurn(){
  if(!gameActive) return;
  startTurnFor(opponent);
  draw(opponent);
  // simple play: try to play one card affordable
  for(let i=0;i<opponent.hand.length;i++){
    const c = opponent.hand[i];
    const cost = getCardCostFor(c, opponent);
    if(cost <= opponent.currMana){
      if(c.type === "monster"){
        opponent.currMana -= cost; opponent.field.push({uid:c.uid,id:c.id,name:c.name,atk:c.atk,canAttack:false,hasAttacked:false}); opponent.hand.splice(i,1); logAction("相手はモンスターを召喚した");
        break;
      } else if(c.type === "field"){
        opponent.currMana -= cost; if(globalField) opponent.grave.push({id:globalField.id,name:globalField.name}); globalField = {id:c.id,name:c.name,desc:c.desc}; opponent.hand.splice(i,1); logAction("相手はフィールドカードを展開した"); break;
      } else if(c.type === "spell"){
        if(c.id === "thunder" || c.id === "relic" || c.id === "heal"){ opponent.currMana -= cost; resolveSpell(c, false); opponent.grave.push({id:c.id,name:c.name}); opponent.hand.splice(i,1); break; }
      }
    }
  }
  // attacks
  opponent.field.forEach(m=>{ m.canAttack = true; m.hasAttacked = false; });
  for(let i=0;i<opponent.field.length;i++){
    const attacker = opponent.field[i];
    if(!attacker.canAttack || attacker.hasAttacked) continue;
    if(player.field.length > 0){
      const idx = Math.floor(Math.random()*player.field.length); const defender = player.field[idx];
      const aAtk = getCardAtk(attacker, opponent); const dAtk = getCardAtk(defender, player);
      if(aAtk > dAtk){ player.grave.push({id:defender.id,name:defender.name}); player.field.splice(idx,1); logAction(`相手の${attacker.name}が${defender.name}を破壊した`); }
      else if(aAtk < dAtk){ opponent.grave.push({id:attacker.id,name:attacker.name}); opponent.field.splice(i,1); logAction(`相手の${attacker.name}は戦闘で破壊された`); }
      else { player.grave.push({id:defender.id,name:defender.name}); opponent.grave.push({id:attacker.id,name:attacker.name}); player.field.splice(idx,1); opponent.field.splice(i,1); logAction(`相手の${attacker.name}と${defender.name}は同値で両方破壊された`); }
    } else {
      player.life -= getCardAtk(attacker, opponent); logAction(`相手の${attacker.name}が直接攻撃し、あなたに${getCardAtk(attacker, opponent)}ダメージ`); 
    }
    attacker.hasAttacked = true;
    if(checkWin()) return;
  }
  // end-phase effects
  triggerEndPhaseEffects(false);
  // prepare next player turn
  startTurnFor(player); draw(player);
  player.field.forEach(m=>{ m.canAttack = true; m.hasAttacked = false; });
  opponent.field.forEach(m=>{ m.canAttack = true; m.hasAttacked = false; });
  playerTurn = true; renderBattle();
}

/* ======================================================
   End-phase effects (monster & field)
   - Kijin effect: end of owner's turn, destroy random opponent monster whose atk <= kijin.atk
   - Necromancer: revive random monster from own grave
   - Field effects: happy / forest / ant_nest / ant_spawn
======================================================*/
function triggerEndPhaseEffects(isPlayer){
  const me = isPlayer ? player : opponent; const opp = isPlayer ? opponent : player;
  const oppHasJyujutsu = opp.field.some(x=>x.id==="jyujutsushi");

  const list = me.field.slice();
  list.forEach(m=>{
    if(m.id === "kijin" && !oppHasJyujutsu){
      if(opp.field.length > 0){
        // choose random opponent monster with atk <= kijin.atk
        const candidates = opp.field.filter(mon => getCardAtk(mon, opp) <= getCardAtk(m, me));
        if(candidates.length > 0){
          const idx = Math.floor(Math.random()*candidates.length); const target = candidates[idx];
          const tIndex = opp.field.indexOf(target);
          if(tIndex>=0){ opp.grave.push({id:target.id,name:target.name}); opp.field.splice(tIndex,1); logAction(`${m.name}の効果で相手の${target.name}を墓地へ送った`); }
        }
      }
    }
    if(m.id === "necromancer" && !oppHasJyujutsu){
      const monsIdx = me.grave.findIndex(g=> { const cd = ALL_CARDS.find(x=>x.id===g.id); return cd && cd.type === "monster"; });
      if(monsIdx >= 0 && me.field.length < 5){
        const g = me.grave.splice(monsIdx,1)[0]; const data = ALL_CARDS.find(x=>x.id===g.id); me.field.push({uid:Math.random(), id:data.id, name:data.name, atk:data.atk, canAttack:false, hasAttacked:false}); logAction(`${m.name}の効果で墓地から${data.name}を召喚した`); }
    }
  });

  if(globalField){
    if(globalField.id === "happy"){ draw(player); draw(opponent); logAction("ハッピーマウンテン: 両者1枚ドロー"); }
    if(globalField.id === "forest"){
      const candidates = [];
      if(player.grave.length>0) candidates.push(player);
      if(opponent.grave.length>0) candidates.push(opponent);
      if(candidates.length>0){
        const pick = candidates[Math.floor(Math.random()*candidates.length)];
        const idx = Math.floor(Math.random()*pick.grave.length); const g = pick.grave.splice(idx,1)[0]; const data = ALL_CARDS.find(x=>x.id===g.id);
        pick.hand.push({uid:Math.random(), id:data.id, name:data.name, type:data.type, cost:data.cost||0, atk:data.atk||0, desc:data.desc||""}); logAction("亡者の森の効果で墓地からカードが手札に戻った");
      }
    }
  }
  // reset temp buffs when appropriate - clear tempBuff on end of turn for those with tempBuff (ant_rage)
  // We'll reset player's temp buffs when their turn ends; already done by clearing at startTurnFor for next owner
  renderBattle();
}

/* ======================================================
   Check win conditions
   - If opponent.life <=0 or player.life <=0, show end modal
   - If player wins during online match (isOnline==true) -> packCount++ (only online wins get packs)
======================================================*/
function checkWinSilent(){
  if(player.life <= 0 || opponent.life <= 0){ showEndModal(); return true; } return false;
}
function checkWin(){
  if(player.life <= 0){ showEndModal(false); return true; }
  if(opponent.life <= 0){
    // if this was an online match (opponent.name not 'CPU'), award pack
    if(opponent.name !== "CPU" && opponent.name !== "CPU" ){
      packCount++; saveAll(); updateTopCounts(); logAction("オンライン勝利報酬: パックを1つ獲得");
    }
    showEndModal(true); return true;
  }
  return false;
}

/* ======================================================
   End modal
======================================================*/
function showEndModal(playerWon){
  gameActive = false;
  const modal = document.getElementById("modal"); const box = document.getElementById("modalBox");
  modal.style.display = "flex";
  if(playerWon === undefined){
    box.innerHTML = `<h3>ゲーム終了</h3><div class="muted">どちらかのライフが0になりました。</div><div style="margin-top:12px"><button class="btn primary" onclick="closeModalAndReturn()">タイトルへ戻る</button></div>`;
  } else if(playerWon){
    box.innerHTML = `<h3>あなたの勝利！</h3><div class="muted">勝利報酬（オンライン勝利の場合）: パックを1つ獲得</div>
      <div style="margin-top:12px"><button class="btn" onclick="rematch()">再戦</button><button class="btn" onclick="closeModalAndReturn()">タイトルへ戻る</button></div>`;
  } else {
    box.innerHTML = `<h3>あなたの敗北...</h3><div style="margin-top:12px"><button class="btn" onclick="rematch()">再戦</button><button class="btn" onclick="closeModalAndReturn()">タイトルへ戻る</button></div>`;
  }
}
function rematch(){ closeModal(); if(Object.keys(savedDecks).length>0){ const n=Object.keys(savedDecks)[0]; startMatchWithDeck(savedDecks[n]); } else startQuickCPUMatch(); }
function closeModalAndReturn(){ closeModal(); document.getElementById("battleArea").style.display="none"; document.getElementById("menu").style.display="flex"; gameActive=false; }

/* ======================================================
   Surrender / debug
======================================================*/
function surrender(){ if(!confirm("本当に降参しますか？")) return; // losing
  logAction("あなたは降参した"); showEndModal(false); }
function debugGivePack(){ packCount++; saveAll(); updateTopCounts(); alert("デバッグ: パック1獲得"); }

/* ======================================================
   Pack wrappers for UI
======================================================*/
function openPackOpener(){ document.getElementById("menu").style.display="none"; document.getElementById("packOpener").style.display="block"; document.getElementById("packResult").innerHTML=""; }
function closePackOpener(){ document.getElementById("packOpener").style.display="none"; document.getElementById("menu").style.display="flex"; }
function openPackManual(){ if(packCount<=0){ alert("パックがありません"); return; } packCount--; saveAll(); updateTopCounts(); const res = openPackInternal(false); showPackResultOnPage(res); }

/* ======================================================
   Selection modal helper (for choosing cards etc.)
   - title: string, candidates: array of card objects, maxSelect: number, callback(selectedArray)
======================================================*/
function showSelectionModal(title, candidates, maxSelect, callback){
  const modal = document.getElementById("modal"); const box = document.getElementById("modalBox");
  box.innerHTML = `<h3>${title}</h3><div id="selArea" style="max-height:300px;overflow:auto"></div><div style="margin-top:8px"><button class="btn" id="confirmSel">決定</button> <button class="btn" onclick="closeModal()">キャンセル</button></div>`;
  const area = document.getElementById("selArea");
  const chosen = new Set();
  candidates.forEach((c, idx)=>{
    const div = document.createElement("div"); div.className="card small"; div.style.display="inline-block";
    div.innerHTML = `<strong>${c.name}</strong><div class="muted">${c.desc||""}</div>`;
    div.onclick = ()=>{
      if(chosen.has(c.id)){ chosen.delete(c.id); div.style.border="1px solid #bbb"; }
      else {
        if(chosen.size >= maxSelect){ alert(`最大${maxSelect}枚まで選択できます`); return; }
        chosen.add(c.id); div.style.border="2px solid #3a87ad";
      }
    };
    area.appendChild(div);
  });
  document.getElementById("confirmSel").onclick = ()=>{
    const selected = candidates.filter(c=> chosen.has(c.id));
    closeModal();
    callback(selected);
  };
  modal.style.display = "flex";
}
function closeModal(){ document.getElementById("modal").style.display = "none"; }

/* ======================================================
   Effect buttons: GoldAnt & AntKing activation
   - These operate per-card and set usedEffectThisTurn on the card
======================================================*/
function updatePerCardEffectButtons(card, owner){
  if(card.id === "goldant"){
    const btn = document.getElementById(`gold-btn-${card.uid}`);
    if(!btn) return;
    const hasTargets = owner.deck.some(x=> ALL_CARDS.find(c=>c.id===x.id).name.includes("アント"));
    if(card.usedEffectThisTurn || !hasTargets) btn.classList.add("disabled"); else btn.classList.remove("disabled");
  }
  if(card.id === "antking"){
    const btn = document.getElementById(`king-btn-${card.uid}`);
    if(!btn) return;
    const hasTargets = owner.grave.some(g=> ALL_CARDS.find(x=>x.id===g.id).name.includes("アント"));
    if(card.usedEffectThisTurn || !hasTargets) btn.classList.add("disabled"); else btn.classList.remove("disabled");
  }
}
function activateGoldAnt(uid){
  if(!playerTurn){ alert("自分のターンのみ使用できます"); return; }
  // find card on player's field
  const c = player.field.find(x=>x.uid===uid);
  if(!c) return;
  if(c.usedEffectThisTurn){ alert("このターンは既に使用済み"); return; }
  // check deck for ant or ant_a
  const choices = player.deck.filter(x=> ALL_CARDS.find(cd=>cd.id===x.id).name.includes("アント")).map(x=>ALL_CARDS.find(cd=>cd.id===x.id));
  if(choices.length===0){ alert("デッキに対象がいません"); return; }
  showSelectionModal("ゴールドアント: デッキから召喚するカードを選択（1枚）", choices, 1, (sel)=>{
    if(sel.length===0) return;
    const chosen = sel[0];
    // remove one from deck
    const di = player.deck.findIndex(x=>x.id===chosen.id); if(di>=0){ const cc=player.deck.splice(di,1)[0]; player.field.push({uid:Math.random(), id:chosen.id, name:chosen.name, atk:chosen.atk, canAttack:true, hasAttacked:false}); logAction(`ゴールドアントの効果で${chosen.name}をデッキから召喚（召喚酔い無し）`); c.usedEffectThisTurn = true; renderBattle(); }
  });
}
function activateAntKing(uid){
  if(!playerTurn){ alert("自分のターンのみ使用できます"); return; }
  const c = player.field.find(x=>x.uid===uid);
  if(!c) return;
  if(c.usedEffectThisTurn){ alert("このターンは既に使用済み"); return; }
  const choices = player.grave.filter(g=> ALL_CARDS.find(x=>x.id===g.id).name.includes("アント")).map(g=>ALL_CARDS.find(x=>x.id===g.id));
  if(choices.length===0){ alert("墓地に対象がいません"); return; }
  showSelectionModal("アントキング: 墓地から最大2枚を選択", choices, 2, (sel)=>{
    sel.forEach(s=>{
      const gi = player.grave.findIndex(g=>g.id===s.id);
      if(gi>=0){ player.grave.splice(gi,1); player.field.push({uid:Math.random(), id:s.id, name:s.name, atk:s.atk, canAttack:true, hasAttacked:false}); }
    });
    if(sel.length>0){ logAction(`アントキングの効果で墓地から${sel.map(x=>x.name).join("と")}を召喚（召喚酔い無し）`); c.usedEffectThisTurn = true; renderBattle(); }
  });
}

/* ======================================================
   Grave display functions
======================================================*/
function toggleGrave(){ const ga=document.getElementById("graveArea"); ga.style.display = ga.style.display === "none" ? "block" : "block"; renderGraveArea(); }
function renderGraveArea(){
  const ga = document.getElementById("graveArea"); ga.innerHTML = `<strong>あなたの墓地</strong><div class="smallText">${player.grave.map(x=>x.name).join(", ") || "(空)"}</div><hr><strong>相手の墓地</strong><div class="smallText">${opponent.grave.map(x=>x.name).join(", ") || "(空)"}</div>`;
}
function showFullGrave(){ showModal(`<h3>墓地詳細</h3><div><strong>あなた:</strong><div class="smallText">${player.grave.map(x=>x.name+" ("+x.id+")").join("<br>")||"(空)"}</div><hr><strong>相手:</strong><div class="smallText">${opponent.grave.map(x=>x.name+" ("+x.id+")").join("<br>")||"(空)"}</div></div>`); }

/* ======================================================
   Action log
======================================================*/
function logAction(text){
  const t = `${new Date().toLocaleTimeString()} - ${text}`;
  actionLog.unshift(t);
  renderLog();
}
function renderLog(){
  const el = document.getElementById("actionLog"); el.innerHTML = actionLog.slice(0,200).map(x=>`<div>${x}</div>`).join("");
}
function clearLog(){ actionLog=[]; renderLog(); }

/* ======================================================
   Utility: showModal helper (simple)
======================================================*/
function showModal(html, closable=true){ const m=document.getElementById("modal"); const box=document.getElementById("modalBox"); box.innerHTML = html + (closable?'<div style="margin-top:12px"><button class="btn" onclick="closeModal()">閉じる</button></div>':'' ); m.style.display='flex'; }
function closeModal(){ document.getElementById("modal").style.display='none'; }

/* ======================================================
   Username / settings
======================================================*/
function openSettings(){ loadAll(); document.getElementById("menu").style.display='none'; document.getElementById("settingsPanel").style.display='block'; document.getElementById("usernameInput").value = username || ""; }
function closeSettings(){ document.getElementById("settingsPanel").style.display='none'; document.getElementById("menu").style.display='flex'; }
function saveUsername(){ username = document.getElementById("usernameInput").value.trim() || "Guest"; saveAll(); updateTopCounts(); alert("ユーザー名を保存しました: " + username); }

/* ======================================================
   Daily packs: claim 2 packs once per day (date based)
======================================================*/
function claimDailyPacks(){
  const today = new Date().toISOString().slice(0,10);
  if(lastDaily === today){ alert("本日は既にデイリーパックを受け取り済みです"); return; }
  packCount += 2; lastDaily = today; saveAll(); updateTopCounts(); alert("本日のデイリーパック2個を受け取りました");
}

/* ======================================================
   Pack selection helpers (for UI open)
======================================================*/
function exchangeShards(){ if(shardCount < 10){ alert("欠片が10個必要です"); return; } shardCount -= 10; packCount++; saveAll(); updateTopCounts(); alert("欠片10個で1パックを獲得しました"); }

/* ======================================================
   initial / reset
======================================================*/
function resetAll(){ if(!confirm("セーブを初期化しますか？")) return; localStorage.removeItem(KEY_COLLECTION); localStorage.removeItem(KEY_PACKS); localStorage.removeItem(KEY_SHARDS); localStorage.removeItem(KEY_DECKS); localStorage.removeItem(KEY_NEW); localStorage.removeItem(KEY_USERNAME); localStorage.removeItem(KEY_LASTDAILY); collection={}; packCount=0; shardCount=0; savedDecks={}; newCards={}; username="Guest"; lastDaily=null; ensureInitial(); alert("初期化しました。ページを再読み込みしてください。"); }

/* ======================================================
   Online/CPU pack rules: CPU wins give no packs; online win gives 1 pack already handled in checkWin
======================================================*/

/* ======================================================
   Utility: show pack on page wrapper for buttons
======================================================*/
document.addEventListener("DOMContentLoaded",()=>{
  loadAll(); ensureInitial(); updateTopCounts();
  // attach functions to global for button handlers
  window.openDeckBuilder = openDeckBuilder; window.closeDeckBuilder = closeDeckBuilder;
  window.openPackOpener = openPackOpener; window.closePackOpener = closePackOpener;
  window.openPackManual = openPackManual; window.exchangeShards = exchangeShards;
  window.openCollection = openCollection; window.closeCollection = closeCollection;
  window.startQuickCPUMatch = startQuickCPUMatch; window.startOnlineMatch = startOnlineMatch;
  window.startMatchWithDeck = startMatchWithDeck; window.saveDeckAndStart = saveDeckAndStart;
  window.openPackOpener = openPackOpener; window.openPackManual = openPackManual;
  // initialStarter needed for first-turn rule tracking
  initialStarter = Math.random() < 0.5 ? "player" : "opponent";
});

/* ======================================================
   Small utility used by card playing: playerAttackTarget when clicking CPU field
   We'll attach clickable behavior by using attackMode state in renderBattle: when attackMode true and
   player clicks a CPU field card, call this function with appropriate indices.
======================================================*/
function playerAttackTarget(selectedAttacker, targetRef){
  // not used in current code, kept for compatibility
}

/* ======================================================
   helper to show modal with HTML content
   (repeated for convenience)
======================================================*/
function showModalHTML(html){ document.getElementById("modalBox").innerHTML = html + '<div style="margin-top:12px"><button class="btn" onclick="closeModal()">閉じる</button></div>'; document.getElementById("modal").style.display='flex'; }

/* ======================================================
   End of script
======================================================*/
</script>

</body>
</html>
