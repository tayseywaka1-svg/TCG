<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8"/>
<title>ブラウザTCG - 完全サンプル</title>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<style>
  body{font-family:system-ui,Arial;background:#f4f6f8;margin:12px;color:#111}
  header{display:flex;justify-content:space-between;align-items:center}
  h1{margin:0;font-size:20px}
  .row{display:flex;gap:12px;align-items:flex-start}
  .panel{background:#fff;border:1px solid #e0e0e0;border-radius:8px;padding:10px;box-shadow:0 1px 3px rgba(0,0,0,0.04)}
  .small{width:280px}
  .btn{padding:6px 10px;border-radius:6px;border:1px solid #333;background:#fff;cursor:pointer;margin:4px}
  .primary{background:#0b6dfd;color:#fff;border-color:#0b6dfd}
  .muted{color:#666;font-size:13px}
  .card{display:inline-block;background:#fff;border:1px solid #ccc;border-radius:8px;padding:6px;margin:6px;width:110px;text-align:center;font-size:13px;cursor:pointer}
  .card img{width:100px;height:70px;object-fit:cover;border-radius:6px}
  .card.small{width:90px;padding:4px;font-size:12px}
  .hand{min-height:80px;border-radius:6px;padding:6px;background:#fbfdff;border:1px dashed #d7e5ff}
  .zone{min-height:80px;padding:8px;border:1px dashed #ddd;border-radius:6px;background:#fff}
  .fieldBox{background:#fff8dc;padding:8px;border-radius:6px;border:1px solid #d7c59a}
  #modal{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,0.5)}
  #modal .box{background:#fff;padding:18px;border-radius:8px;min-width:320px;text-align:center}
  .log{height:220px;overflow:auto;background:#fff;border:1px solid #ddd;padding:8px;border-radius:6px}
  .deckArea, .collectionArea{min-height:300px;max-height:520px;overflow:auto;padding:8px;background:#fff;border:1px solid #eee;border-radius:6px}
  .dropTarget{min-height:120px;padding:8px;border-radius:8px;border:2px dashed #ccc;background:#fafafa}
  input[type=text]{padding:6px;border-radius:6px;border:1px solid #ccc;width:180px}
  footer{margin-top:12px;font-size:12px;color:#666}
  .mutedSmall{font-size:11px;color:#777}
</style>
</head>
<body>
<header>
  <div>
    <h1>ブラウザTCG - 完全サンプル</h1>
    <div class="muted">ローカル保存 (localStorage) / CPU戦専用</div>
  </div>
  <div class="panel small">
    <div><strong>ユーザー:</strong> <span id="usernameDisplay">Guest</span></div>
    <div style="margin-top:6px"><strong>所持パック:</strong> <span id="packCount">0</span></div>
    <div><strong>欠片:</strong> <span id="shardCount">0</span>（10で1パック）</div>
    <div style="margin-top:8px">
      <button class="btn" onclick="openDeckBuilder()">デッキ構築</button>
      <button class="btn" onclick="openPackOpener()">パック開封</button>
      <button class="btn" onclick="openCollection()">所持カード</button>
      <button class="btn primary" onclick="startCPUQuickMatch()">CPU戦（自動デッキ）</button>
    </div>
  </div>
</header>

<main style="display:grid;grid-template-columns:1fr 360px;gap:12px;margin-top:12px">
  <section>
    <!-- バトルエリア -->
    <div id="battleArea" class="panel" style="display:none">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong id="playerNameLabel">あなた</strong> ライフ: <span id="playerLife">20</span> ｜ マナ: <span id="playerMana">0</span>/<span id="playerMaxMana">0</span></div>
        <div>
          <button class="btn" onclick="surrender()">降参</button>
        </div>
        <div><strong id="cpuNameLabel">CPU</strong> ライフ: <span id="cpuLife">20</span> ｜ マナ: <span id="cpuMana">0</span>/<span id="cpuMaxMana">0</span></div>
      </div>

      <div style="margin-top:8px" id="fieldCardArea">
        <div class="fieldBox" id="fieldCardBox">フィールド: なし</div>
      </div>

      <div style="margin-top:10px"><strong>相手フィールド</strong><div id="cpuField" class="zone"></div></div>
      <div style="margin-top:10px"><strong>あなたのフィールド</strong><div id="playerField" class="zone"></div></div>
      <div style="margin-top:10px"><strong>あなたの手札（クリックでプレイ）</strong><div id="playerHand" class="hand"></div></div>

      <div style="margin-top:10px;display:flex;gap:8px;align-items:center">
        <button class="btn" onclick="endTurn()">ターン終了</button>
        <button class="btn primary" onclick="attackModeToggle()">攻撃モード</button>
        <button class="btn" onclick="toggleGrave()">墓地表示</button>
        <span class="muted" id="modeHint"></span>
      </div>
    </div>

    <!-- デッキ構築画面 -->
    <div id="deckBuilder" class="panel" style="display:none">
      <h3>デッキ構築（ドラッグ＆ドロップ）</h3>
      <div style="display:flex;gap:12px">
        <div style="flex:1">
          <div class="muted">所持カード（ドラッグして右のデッキへ）</div>
          <div id="collectionArea" class="collectionArea"></div>
        </div>
        <div style="width:380px">
          <div class="muted">デッキ（30枚にしてください）</div>
          <div id="deckArea" class="deckArea dropTarget" ondragover="allowDrop(event)" ondrop="onDropToDeck(event)"></div>
          <div style="margin-top:8px">
            <input id="deckName" placeholder="デッキ名（例: 初心者）" type="text"/>
            <button class="btn" onclick="saveCurrentDeck()">保存</button>
            <button class="btn primary" onclick="saveDeckAndStart()">保存して開始</button>
            <button class="btn" onclick="closeDeckBuilder()">閉じる</button>
            <button class="btn" onclick="clearCurrentDeck()">クリア</button>
          </div>
          <div style="margin-top:8px"><strong>保存済みデッキ</strong><div id="savedDecks"></div></div>
        </div>
      </div>
    </div>

    <!-- パック開封 -->
    <div id="packOpener" class="panel" style="display:none">
      <h3>パック開封</h3>
      <div style="display:flex;gap:8px;align-items:center">
        <button class="btn" onclick="openPackManual()">1パック開封</button>
        <button class="btn" onclick="exchangeShards()">欠片10個で1パック交換</button>
        <div class="muted">（所持パックはトップに表示）</div>
      </div>
      <div id="packResult" style="margin-top:12px"></div>
      <div style="margin-top:8px"><button class="btn" onclick="closePackOpener()">閉じる</button></div>
    </div>

    <!-- 所持カード詳細 -->
    <div id="collectionPanel" class="panel" style="display:none">
      <h3>所持カード（効果表示）</h3>
      <div id="collectionList" class="collectionArea"></div>
      <div style="margin-top:8px"><button class="btn" onclick="closeCollection()">閉じる</button></div>
    </div>

  </section>

  <aside>
    <div class="panel" style="margin-bottom:12px">
      <h3>行動履歴</h3>
      <div id="actionLog" class="log"></div>
      <div style="margin-top:6px"><button class="btn" onclick="clearLog()">ログクリア</button></div>
    </div>

    <div class="panel" style="margin-bottom:12px">
      <h3>墓地</h3>
      <div id="graveArea" style="min-height:120px;max-height:220px;overflow:auto"></div>
      <div style="margin-top:6px"><button class="btn" onclick="showFullGrave()">詳細表示</button></div>
    </div>

    <div class="panel">
      <h3>設定</h3>
      <div>ユーザー名: <input id="usernameInput" type="text" placeholder="表示名を入力"/></div>
      <div style="margin-top:6px"><button class="btn" onclick="saveUsername()">保存</button></div>
    </div>
  </aside>
</main>

<div id="modal"><div class="box" id="modalBox"></div></div>
<footer class="muted">注: CPU戦勝利ではパックは付与されません。デバッグでのパック付与・チート機能はありません。</footer>

<script>
/* ===========================================================
   カード定義（画像は placeholder）、レアリティ、効果はdescで説明
   - 必要なカードを列挙（ユーザーが追加したものもここへ）
   ===========================================================*/
const ALL_CARDS = [
  {id:"slime", name:"スライム", type:"monster", cost:1, atk:1, desc:"召喚時: デッキにスライムがあれば1枚手札に加える", rarity:"C", img:imgFor("スライム")},
  {id:"kijin", name:"鬼人", type:"monster", cost:5, atk:4, desc:"エンド時: 相手場のATK≤鬼人ATKのモンスターをランダムで1体墓地へ", rarity:"C", img:imgFor("鬼人")},
  {id:"necromancer", name:"ネクロマンサー", type:"monster", cost:4, atk:2, desc:"エンド時: 自墓地からランダムでモンスターを召喚", rarity:"C", img:imgFor("ネクロマンサー")},
  {id:"jyujutsushi", name:"呪術師", type:"monster", cost:4, atk:2, desc:"場にいる間: 相手モンスターの効果無効化", rarity:"C", img:imgFor("呪術師")},
  {id:"golem", name:"ゴーレム", type:"monster", cost:3, atk:4, desc:"効果なし", rarity:"UC", img:imgFor("ゴーレム")},
  {id:"speedgolem", name:"スピードゴーレム", type:"monster", cost:5, atk:3, desc:"このモンスターは1ターンに2回攻撃できる", rarity:"R", img:imgFor("スピードゴーレム")},
  {id:"attackgolem", name:"アタックゴーレム", type:"monster", cost:5, atk:5, desc:"効果なし", rarity:"R", img:imgFor("アタックゴーレム")},
  {id:"ultgolem", name:"アルティメットゴーレム", type:"monster", cost:20, atk:6, desc:"特殊召喚専用：ゴーレム系3体を生贄に特殊召喚可能", rarity:"SR", img:imgFor("アルティメットゴーレム")},
  {id:"ant", name:"アント", type:"monster", cost:1, atk:1, desc:"召喚時: デッキにアントαがいれば1枚手札に加える", rarity:"UC", img:imgFor("アント")},
  {id:"ant_a", name:"アントα", type:"monster", cost:1, atk:1, desc:"召喚時: デッキからアントを含むカードを1枚手札に加える", rarity:"UC", img:imgFor("アントα")},
  {id:"ironant", name:"アイアンアント", type:"monster", cost:2, atk:3, desc:"効果なし", rarity:"R", img:imgFor("アイアンアント")},
  {id:"goldant", name:"ゴールドアント", type:"monster", cost:3, atk:3, desc:"起動(1ターン1回): デッキからアント/アントαを場に出す（酔いなし）", rarity:"RR", img:imgFor("ゴールドアント")},
  {id:"antking", name:"アントキング", type:"monster", cost:4, atk:4, desc:"起動(1ターン1回): 墓地からアント系を最大2体召喚（酔いなし）", rarity:"SR", img:imgFor("アントキング")},
  {id:"heal", name:"ヒーリングライト", type:"spell", cost:2, desc:"自分のライフを3回復", rarity:"C", img:imgFor("ヒーリングライト")},
  {id:"sacrifice", name:"ダークサクリファイス", type:"spell", cost:3, desc:"自分のモンスター1体を破壊→そのATK分相手にダメージ", rarity:"C", img:imgFor("ダークサクリファイス")},
  {id:"thunder", name:"雷撃", type:"spell", cost:4, desc:"相手に2ダメージ", rarity:"C", img:imgFor("雷撃")},
  {id:"relic", name:"亡者の遺品", type:"spell", cost:2, desc:"自分の墓地のカード1枚を手札に戻す", rarity:"C", img:imgFor("亡者の遺品")},
  {id:"ant_egg", name:"アントの卵", type:"spell", cost:2, desc:"山札からアント名を含むカードを最大2枚まで手札に加える（シャッフル）", rarity:"UC", img:imgFor("アントの卵")},
  {id:"ant_rage", name:"アントの逆襲", type:"spell", cost:2, desc:"このターン、自分のアントのATK+1（ターン終了時に戻る）", rarity:"UC", img:imgFor("アントの逆襲")},
  {id:"ant_grow", name:"アントの育成", type:"spell", cost:2, desc:"このターン、自分のアントのコスト-1（最低0）", rarity:"UC", img:imgFor("アントの育成")},
  {id:"ant_awake", name:"アントの覚醒", type:"spell", cost:1, desc:"自分の場の全アントの召喚酔いを解除（既に場にいるもの含む）", rarity:"UC", img:imgFor("アントの覚醒")},
  {id:"snipe", name:"狙い撃ち", type:"spell", cost:4, desc:"相手のATK4以下のモンスターを1体墓地へ（相手限定）", rarity:"R", img:imgFor("狙い撃ち")},
  {id:"research", name:"博士の研究", type:"spell", cost:1, desc:"2枚ドロー（このターン1回）", rarity:"C", img:imgFor("博士の研究")},
  {id:"magic_search", name:"マジックサーチ", type:"spell", cost:2, desc:"山札から魔法カードを1枚手札に加える（非公開）", rarity:"C", img:imgFor("マジックサーチ")},
  {id:"monster_search", name:"モンスターサーチ", type:"spell", cost:2, desc:"山札からモンスターを1枚手札に加える（非公開）", rarity:"C", img:imgFor("モンスターサーチ")},
  {id:"happy", name:"ハッピーマウンテン", type:"field", cost:2, desc:"エンド時: 両者1ドロー", rarity:"C", img:imgFor("ハッピーマウンテン")},
  {id:"forest", name:"亡者の森", type:"field", cost:3, desc:"エンド時: ランダムな墓地のカード1枚を持ち主の手札へ", rarity:"R", img:imgFor("亡者の森")},
  {id:"ant_nest", name:"アントの巣", type:"field", cost:2, desc:"アント系のATK+1（常時）", rarity:"R", img:imgFor("アントの巣")},
  {id:"ant_spawn", name:"アントの産卵場", type:"field", cost:3, desc:"両者のアントのコスト-1（常時）", rarity:"R", img:imgFor("アントの産卵場")}
];

/* ラリティ重み（パック抽選） */
const RARITY_WEIGHTS = [{r:"C",w:60},{r:"UC",w:25},{r:"R",w:10},{r:"RR",w:4},{r:"SR",w:1}];

/* localStorageキー */
const KEY_COLLECTION = "tcg_collection_v_final";
const KEY_PACKS = "tcg_packs_v_final";
const KEY_SHARDS = "tcg_shards_v_final";
const KEY_DECKS = "tcg_decks_v_final";
const KEY_USER = "tcg_user_v_final";
const KEY_LASTDAILY = "tcg_daily_v_final";

/* 状態 */
let collection = {}; // {cardId:count}
let packCount = 0;
let shardCount = 0;
let savedDecks = {};
let username = localStorage.getItem(KEY_USER) || "Guest";
let lastDaily = localStorage.getItem(KEY_LASTDAILY) || null;

/* バトル状態 */
let currentDeck = [];
let player = null, cpu = null;
let globalField = null;
let playerTurn = true;
let initialFirstPlayer = null;
let gameActive = false;
let actionLog = [];
let attackMode = false;
let selectedAttacker = null;

/* ---------------------------
   helper: placeholder image
----------------------------*/
function imgFor(name){ return `https://via.placeholder.com/200x140.png?text=${encodeURIComponent(name)}`; }

/* ---------------------------
   storage helpers
----------------------------*/
function saveAll(){
  localStorage.setItem(KEY_COLLECTION, JSON.stringify(collection));
  localStorage.setItem(KEY_PACKS, String(packCount));
  localStorage.setItem(KEY_SHARDS, String(shardCount));
  localStorage.setItem(KEY_DECKS, JSON.stringify(savedDecks));
  localStorage.setItem(KEY_USER, username);
  localStorage.setItem(KEY_LASTDAILY, lastDaily || "");
}
function loadAll(){
  collection = JSON.parse(localStorage.getItem(KEY_COLLECTION) || "{}");
  packCount = parseInt(localStorage.getItem(KEY_PACKS) || "0");
  shardCount = parseInt(localStorage.getItem(KEY_SHARDS) || "0");
  savedDecks = JSON.parse(localStorage.getItem(KEY_DECKS) || "{}");
  username = localStorage.getItem(KEY_USER) || username;
  lastDaily = localStorage.getItem(KEY_LASTDAILY) || null;
}
function updateTop(){ document.getElementById("packCount").textContent = packCount; document.getElementById("shardCount").textContent = shardCount; document.getElementById("usernameDisplay").textContent = username; }

/* ---------------------------
   initial packs & daily (初回10パックは中身を直接コレクションへ)
----------------------------*/
function ensureInitial(){
  loadAll();
  if(Object.keys(collection).length === 0 && packCount === 0 && shardCount === 0){
    for(let i=0;i<10;i++) openPackInternal(true); // コレクションに追加するだけ
    packCount = 0; // 最初の10パックは配布済みとしてパック欄に残さない
    saveAll();
    alert("初期10パックを配布しました（コレクションに追加）");
  }
  checkDaily();
  updateTop();
}
function checkDaily(){
  const today = new Date().toISOString().slice(0,10);
  if(lastDaily !== today){
    packCount += 2;
    lastDaily = today;
    saveAll(); updateTop();
    alert("デイリーボーナス：パック2つを獲得しました");
  }
}

/* ---------------------------
   pack ロジック
----------------------------*/
function pickRarity(){
  const total = RARITY_WEIGHTS.reduce((s,x)=>s+x.w,0);
  let r = Math.random()*total;
  for(const w of RARITY_WEIGHTS){ if(r < w.w) return w.r; r -= w.w; }
  return "C";
}
function pickCardByRarity(r){
  const pool = ALL_CARDS.filter(c=>c.rarity === r);
  if(pool.length === 0) return ALL_CARDS[Math.floor(Math.random()*ALL_CARDS.length)];
  return pool[Math.floor(Math.random()*pool.length)];
}
function addCardToCollection(id){
  const owned = collection[id] || 0;
  if(owned < 4){ collection[id] = owned + 1; return {isNew: owned===0, shard:false}; }
  else { shardCount++; return {isNew:false, shard:true}; }
}
function openPackInternal(silent=false){
  const results = [];
  for(let i=0;i<5;i++){
    const r = pickRarity();
    const c = pickCardByRarity(r);
    const res = addCardToCollection(c.id);
    results.push({card:c, rarity:r, shardGained:res.shard, isNew:res.isNew});
  }
  saveAll(); updateTop();
  if(!silent) showPackResultOnPage(results);
  return results;
}
function openPackManual(){ if(packCount <= 0){ alert("パックがありません"); return; } packCount--; saveAll(); updateTop(); openPackInternal(false); }
function exchangeShards(){ if(shardCount < 10){ alert("欠片が10個必要です"); return; } shardCount -= 10; packCount++; saveAll(); updateTop(); alert("欠片10で1パック獲得しました"); }
function showPackResultOnPage(results){
  const area = document.getElementById("packResult");
  area.innerHTML = "<h4>開封結果</h4>";
  results.forEach(r=>{
    const d = document.createElement("div"); d.className="card small";
    d.innerHTML = `<img src="${r.card.img}"><div>${r.card.name}</div><div class="mutedSmall">${r.rarity}${r.shardGained?' （欠片+1）':''}${r.isNew? ' <strong style="color:#c00">NEW!</strong>':''}</div>`;
    area.appendChild(d);
  });
}

/* ---------------------------
   デッキ構築（ドラッグ＆ドロップ）
----------------------------*/
let deckWorking = [];
function renderCollection(){
  const area = document.getElementById("collectionArea");
  area.innerHTML = "";
  ALL_CARDS.forEach(c=>{
    const owned = collection[c.id] || 0;
    const inDeck = deckWorking.filter(x=>x===c.id).length;
    const d = document.createElement("div"); d.className="card";
    d.draggable = true;
    d.ondragstart = ev => { ev.dataTransfer.setData("text/plain", c.id); ev.dataTransfer.setData("from","collection"); };
    d.innerHTML = `<img src="${c.img}"><div><strong>${c.name}</strong></div><div class="muted">${c.type} / cost:${c.cost||0} atk:${c.atk||"-"}</div><div style="font-size:12px">${c.desc}</div><div>所持:${owned} / デッキ:${inDeck}</div>`;
    area.appendChild(d);
  });
}
function renderDeckArea(){
  const area = document.getElementById("deckArea");
  area.innerHTML = `<div class="muted">デッキ (${deckWorking.length}/30) - ドロップして追加（カードをドラッグして戻すと削除）</div>`;
  deckWorking.forEach((id, idx)=>{
    const c = ALL_CARDS.find(x=>x.id===id);
    const d = document.createElement("div"); d.className="card";
    d.draggable = true;
    d.ondragstart = ev => { ev.dataTransfer.setData("text/plain", String(idx)); ev.dataTransfer.setData("from","deck"); };
    d.innerHTML = `<img src="${c.img}"><div>${c.name}</div><div class="muted">cost:${c.cost||0} atk:${c.atk||"-"}</div><div style="font-size:12px">${c.desc}</div>`;
    area.appendChild(d);
  });
  renderSavedDecks();
}
function allowDrop(e){ e.preventDefault(); }
function onDropToDeck(e){
  e.preventDefault();
  const from = e.dataTransfer.getData("from");
  if(from === "collection"){
    const id = e.dataTransfer.getData("text/plain");
    const owned = collection[id] || 0;
    const inDeck = deckWorking.filter(x=>x===id).length;
    if(deckWorking.length >= 30){ alert("デッキは30枚までです"); return; }
    if(inDeck >= 4){ alert("同じカードは4枚までです"); return; }
    if(inDeck >= owned){ alert("所持枚数を超えています"); return; }
    deckWorking.push(id);
  } else if(from === "deck"){
    const idx = parseInt(e.dataTransfer.getData("text/plain"));
    if(!isNaN(idx)) deckWorking.splice(idx,1);
  }
  renderDeckArea(); renderCollection();
}

/* saved decks */
function renderSavedDecks(){
  const area = document.getElementById("savedDecks"); area.innerHTML = "";
  for(const name in savedDecks){
    const row = document.createElement("div");
    row.innerHTML = `<strong>${name}</strong> (${savedDecks[name].length}) <button class="btn" onclick="loadDeck(${JSON.stringify(name)})">読み込み</button> <button class="btn" onclick="deleteDeck(${JSON.stringify(name)})">削除</button>`;
    area.appendChild(row);
  }
}
function loadDeck(name){ deckWorking = savedDecks[name].slice(); renderDeckArea(); renderCollection(); alert("デッキを読み込みました: " + name); }
function deleteDeck(name){ if(confirm(name + " を削除しますか？")){ delete savedDecks[name]; saveAll(); renderSavedDecks(); alert("削除しました"); } }
function saveCurrentDeck(){
  const name = document.getElementById("deckName").value.trim();
  if(!name){ alert("デッキ名を入力してください"); return; }
  if(deckWorking.length !== 30){ alert("デッキは30枚にしてください"); return; }
  savedDecks[name] = deckWorking.slice();
  saveAll(); renderSavedDecks(); alert("デッキを保存しました: " + name);
}
function saveDeckAndStart(){
  if(deckWorking.length !== 30){ alert("デッキは30枚にしてください"); return; }
  saveAll();
  startMatchWithDeck(deckWorking);
}
function clearCurrentDeck(){ if(confirm("デッキをクリアしますか？")){ deckWorking = []; renderDeckArea(); renderCollection(); } }

/* UI open/close */
function openDeckBuilder(){ loadAll(); deckWorking = []; // default start empty; could copy saved deck if desired
  renderCollection(); renderDeckArea(); document.getElementById("deckBuilder").style.display="block"; document.getElementById("battleArea").style.display="none"; document.getElementById("packOpener").style.display="none"; document.getElementById("collectionPanel").style.display="none"; updateTop(); }
function closeDeckBuilder(){ document.getElementById("deckBuilder").style.display="none"; }
function openPackOpener(){ document.getElementById("packOpener").style.display="block"; document.getElementById("deckBuilder").style.display="none"; document.getElementById("collectionPanel").style.display="none"; updateTop(); }
function closePackOpener(){ document.getElementById("packOpener").style.display="none"; updateTop(); }
function openCollection(){ renderCollectionList(); document.getElementById("collectionPanel").style.display="block"; document.getElementById("deckBuilder").style.display="none"; document.getElementById("packOpener").style.display="none"; }
function closeCollection(){ document.getElementById("collectionPanel").style.display="none"; }

/* collection list */
function renderCollectionList(){
  const area = document.getElementById("collectionList"); area.innerHTML = "";
  ALL_CARDS.forEach(c=>{
    const owned = collection[c.id] || 0;
    const d = document.createElement("div"); d.className="card small";
    d.innerHTML = `<img src="${c.img}"><div><strong>${c.name}</strong></div><div class="muted">${c.type} / cost:${c.cost||0} atk:${c.atk||"-"}</div><div style="font-size:12px">${c.desc}</div><div>所持:${owned}</div>`;
    area.appendChild(d);
  });
}

/* ---------------------------
   match start / draw / shuffle / mana
----------------------------*/
function startCPUQuickMatch(){
  loadAll();
  if(Object.keys(collection).length === 0) ensureInitial();
  // CPU deck: random fill using collection if present else fill with slimes
  const deck = [];
  for(const c of ALL_CARDS){
    const own = collection[c.id]||0;
    const add = Math.min(4, own);
    for(let i=0;i<add && deck.length<30;i++) deck.push(c.id);
  }
  while(deck.length<30) deck.push("slime");
  // shuffle and use as both player's deck or player's default? We'll ask user to prepare a deck;
  // If no saved deck exists, auto-fill player's deck from collection
  let playerDeck = [];
  // try to load a saved deck if any
  const firstSaved = Object.keys(savedDecks)[0];
  if(firstSaved){ playerDeck = savedDecks[firstSaved].slice(); }
  else {
    // build from collection
    for(const c of ALL_CARDS){
      const own = collection[c.id]||0;
      const add = Math.min(4, own);
      for(let i=0;i<add && playerDeck.length<30;i++) playerDeck.push(c.id);
    }
    while(playerDeck.length<30) playerDeck.push("slime");
  }
  currentDeck = playerDeck.slice();
  startMatchWithDeck(currentDeck, deck); // player's deck, cpu deck
}

function startMatchWithDeck(playerDeckList, cpuDeckListOverride){
  player = { name: username || "Guest", life:20, deck: playerDeckList.map(id=>({id, uid:Math.random()})), hand:[], field:[], grave:[], maxMana:0, currMana:0, turnCount:0, usedResearch:false, antCostReduction:0 };
  cpu   = { name: "CPU", life:20, deck: (cpuDeckListOverride || playerDeckList).map(id=>({id, uid:Math.random()})), hand:[], field:[], grave:[], maxMana:0, currMana:0, turnCount:0, usedResearch:false, antCostReduction:0 };
  shuffle(player.deck); shuffle(cpu.deck);
  player.hand=[]; cpu.hand=[];
  for(let i=0;i<5;i++){ draw(player); draw(cpu); }
  globalField = null;
  playerTurn = Math.random() < 0.5;
  initialFirstPlayer = playerTurn ? "player" : "cpu";
  gameActive = true;
  actionLog = [];
  attackMode = false; selectedAttacker = null;
  document.getElementById("battleArea").style.display = "block";
  document.getElementById("deckBuilder").style.display = "none";
  document.getElementById("packOpener").style.display = "none";
  document.getElementById("collectionPanel").style.display = "none";
  logAction(`対戦開始: ${player.name} vs CPU （${playerTurn ? "あなたが先攻":"あなたが後攻"}）`);
  // start first player's turn
  startTurn(playerTurn ? player : cpu);
  renderBattle();
  if(!playerTurn) setTimeout(cpuTurnMain, 600);
}

function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } }
function draw(side){ if(side.deck.length === 0) return; const card = side.deck.pop(); const data = ALL_CARDS.find(x=>x.id===card.id); side.hand.push({uid:card.uid,id:data.id,name:data.name,type:data.type,cost:data.cost||0,atk:data.atk||0,desc:data.desc,img:data.img}); }

/* mana */
function startTurn(side){
  side.turnCount = (side.turnCount||0) + 1;
  side.maxMana = Math.min((side.maxMana||0) + 1, 10);
  side.currMana = side.maxMana;
  side.usedResearch = false;
  side.antCostReduction = 0;
  side.field.forEach(m=>{ m.canAttack = true; m.hasAttacked = false; m.tempBuff = m.tempBuff || 0; m.extraAttacksUsed = 0; });
  logAction(`${side === player ? "あなた" : "CPU"} のターン開始（ターン ${side.turnCount}）`);
}

/* ---------------------------
   render battle UI
----------------------------*/
function renderBattle(){
  if(!player) return;
  document.getElementById("playerLife").textContent = player.life;
  document.getElementById("cpuLife").textContent = cpu.life;
  document.getElementById("playerMana").textContent = player.currMana;
  document.getElementById("playerMaxMana").textContent = player.maxMana;
  document.getElementById("cpuMana").textContent = cpu.currMana;
  document.getElementById("playerNameLabel").textContent = player.name;
  document.getElementById("cpuNameLabel").textContent = cpu.name;
  document.getElementById("fieldCardBox").innerHTML = globalField ? `<strong>フィールド:</strong> ${globalField.name}<div class="muted">${globalField.desc}</div>` : "フィールド: なし";

  const cpuF = document.getElementById("cpuField"); cpuF.innerHTML = "";
  cpu.field.forEach((c, idx)=>{
    const div = document.createElement("div"); div.className="card";
    div.innerHTML = `<img src="${c.img}"><div>${c.name}</div><div class="muted">ATK:${c.atk + (c.tempBuff||0)}</div>`;
    if(attackMode && playerTurn){ div.style.border = "2px solid #c33"; div.style.cursor="pointer"; div.onclick = ()=> { if(selectedAttacker) playerAttackTarget(selectedAttacker, {owner:cpu,index:idx}); }; }
    cpuF.appendChild(div);
  });

  const plF = document.getElementById("playerField"); plF.innerHTML = "";
  player.field.forEach((c, idx)=>{
    const div = document.createElement("div"); div.className="card";
    let html = `<img src="${c.img}"><div>${c.name}</div><div class="muted">ATK:${c.atk + (c.tempBuff||0)}</div>`;
    if(c.canAttack && !c.hasAttacked && playerTurn){
      html += `<div style="margin-top:6px"><button class="btn" onclick="enterAttackMode(${idx})">攻撃</button> <button class="btn" onclick="directAttack(${idx})">直接攻撃</button></div>`;
    } else {
      if(!c.canAttack) html += `<div class="muted">(召喚酔い)</div>`;
      if(c.hasAttacked) html += `<div class="muted">(攻撃済)</div>`;
    }
    div.innerHTML = html;
    plF.appendChild(div);
  });

  const ph = document.getElementById("playerHand"); ph.innerHTML = "";
  player.hand.forEach((c, idx)=>{
    const d = document.createElement("div"); d.className="card";
    d.innerHTML = `<img src="${c.img}"><div><strong>${c.name}</strong></div><div class="muted">${c.type} / cost:${getCardCostFor(c,player)}</div><div style="font-size:12px">${c.desc||""}</div>`;
    d.onclick = ()=> playCardFromHand(idx);
    ph.appendChild(d);
  });

  renderGraveArea();
  renderLog();
  document.getElementById("modeHint").textContent = attackMode ? "攻撃モード:相手モンスターをクリック" : "";
}

/* ---------------------------
   cost calculation (field effects)
----------------------------*/
function getCardCostFor(cardObj, side){
  let base = cardObj.cost || 0;
  if(globalField && globalField.id === "ant_spawn" && cardObj.name.includes("アント")) base = Math.max(0, base - 1);
  if(side && side.antCostReduction) base = Math.max(0, base - side.antCostReduction);
  return base;
}

/* ---------------------------
   play card from hand (プレイ)
----------------------------*/
function playCardFromHand(idx){
  if(!playerTurn){ alert("自分のターンではありません"); return; }
  const card = player.hand[idx];
  const cost = getCardCostFor(card, player);
  if(player.currMana < cost){ alert("マナが足りません"); return; }
  // 先行1ターン目はモンスター禁止
  if(card.type === "monster" && initialFirstPlayer === "player" && player.turnCount === 1 && playerTurn){
    alert("先行の1ターン目はモンスターを召喚できません");
    return;
  }
  player.currMana -= cost;

  if(card.type === "monster"){
    if(card.id === "ultgolem"){ alert("アルティメットゴーレムは特殊召喚でのみ出せます"); return; }
    const m = { uid: card.uid, id: card.id, name: card.name, atk: card.atk, canAttack:false, hasAttacked:false, tempBuff:0, extraAttacks: (card.id==="speedgolem"?2:1), img:card.img };
    player.field.push(m);
    logAction(`あなたは ${card.name} を召喚`);
    if(card.id === "slime"){
      const dIdx = player.deck.findIndex(x=>x.id==="slime");
      if(dIdx >= 0){
        const cc = player.deck.splice(dIdx,1)[0]; const dat = ALL_CARDS.find(x=>x.id===cc.id);
        player.hand.push({uid:cc.uid,id:dat.id,name:dat.name,type:dat.type,cost:dat.cost||0,atk:dat.atk||0,desc:dat.desc,img:dat.img});
        logAction("スライム効果でデッキからスライムを手札に加えた");
      }
    }
  } else if(card.type === "spell"){
    resolveSpell(card, true);
    player.grave.push({id:card.id, name:card.name});
    logAction(`あなたは魔法 ${card.name} を使用`);
  } else if(card.type === "field"){
    if(globalField) player.grave.push({id:globalField.id, name:globalField.name});
    globalField = {id:card.id, name:card.name, desc:card.desc};
    logAction(`フィールド ${card.name} を展開`);
  }

  player.hand.splice(idx,1);
  renderBattle();
}

/* ---------------------------
   spell 解決
----------------------------*/
function resolveSpell(card, isPlayer){
  const me = isPlayer? player : cpu;
  const opp = isPlayer? cpu : player;
  if(card.id==="heal"){ me.life += 3; logAction(`${isPlayer? "あなた":"CPU"} が3ライフ回復`); }
  if(card.id==="sacrifice"){
    if(me.field.length > 0){
      const m = me.field.pop();
      me.grave.push({id:m.id, name:m.name});
      opp.life -= m.atk;
      logAction(`${m.name} を破壊して ${m.atk} ダメージ`);
    }
  }
  if(card.id==="thunder"){ opp.life -= 2; logAction("雷撃で相手に2ダメージ"); }
  if(card.id==="relic"){
    if(me.grave.length > 0){
      const idx = Math.floor(Math.random()*me.grave.length);
      const g = me.grave.splice(idx,1)[0];
      const data = ALL_CARDS.find(x=>x.id===g.id);
      me.hand.push({uid:Math.random(), id:data.id, name:data.name, type:data.type, cost:data.cost||0, atk:data.atk||0, desc:data.desc, img:data.img});
      logAction("亡者の遺品で墓地からカードを回収");
    }
  }
  if(card.id==="ant_egg"){
    let added = 0;
    for(let i=me.deck.length-1;i>=0 && added<2;i--){
      const c = me.deck[i]; const dat = ALL_CARDS.find(x=>x.id === c.id);
      if(dat && dat.name.includes("アント")){
        const cc = me.deck.splice(i,1)[0];
        const dat2 = ALL_CARDS.find(x=>x.id===cc.id);
        me.hand.push({uid:cc.uid,id:dat2.id,name:dat2.name,type:dat2.type,cost:dat2.cost||0,atk:dat2.atk||0,desc:dat2.desc,img:dat2.img});
        added++;
      }
    }
    shuffle(me.deck);
    logAction(`アントの卵で${added}枚を手札に加えた`);
  }
  if(card.id==="ant_rage"){ me.field.forEach(c=>{ if(c.name.includes("アント")) c.tempBuff = (c.tempBuff||0) + 1; }); logAction("アントの逆襲でアントのATK+1（ターン終了まで）"); }
  if(card.id==="ant_grow"){ me.antCostReduction = 1; logAction("アントの育成でアントのコスト-1（ターン中）"); }
  if(card.id==="ant_awake"){ me.field.forEach(c=>{ if(c.name.includes("アント")) c.canAttack = true; }); logAction("アントの覚醒でアントの召喚酔い解除"); }
  if(card.id==="snipe"){
    const targets = opp.field.filter(m=> m.atk <= 4);
    if(targets.length>0){ const t=targets[0]; const idx = opp.field.indexOf(t); opp.grave.push({id:t.id,name:t.name}); opp.field.splice(idx,1); logAction(`狙い撃ちで相手の${t.name}を墓地へ`); } else logAction("狙い撃ちの対象がいません");
  }
  if(card.id==="research"){
    if(me.usedResearch){ alert("博士の研究はこのターン使用済みです"); return; }
    draw(me); draw(me); me.usedResearch = true; logAction("博士の研究で2枚ドロー");
  }
  if(card.id==="magic_search" || card.id==="monster_search"){
    const pool = me.deck.filter(x=> ALL_CARDS.find(c=>c.id===x.id).type === (card.id==="magic_search"? "spell":"monster"));
    if(pool.length>0){
      const target = pool[0];
      const idx = me.deck.findIndex(x=>x.id===target.id);
      const cc = me.deck.splice(idx,1)[0];
      const dat = ALL_CARDS.find(x=>x.id===cc.id);
      me.hand.push({uid:cc.uid,id:dat.id,name:dat.name,type:dat.type,cost:dat.cost||0,atk:dat.atk||0,desc:dat.desc,img:dat.img});
      logAction(`${card.name} でカードをサーチしました`);
    } else logAction("サーチ対象なし");
  }
  renderBattle();
}

/* ---------------------------
   attack logic (player)
----------------------------*/
function attackModeToggle(){ attackMode = !attackMode; selectedAttacker = null; renderBattle(); }
function enterAttackMode(index){ const m = player.field[index]; if(!m) return; if(!m.canAttack || m.hasAttacked){ alert("攻撃不可"); return; } selectedAttacker = m; attackMode=true; renderBattle(); }
function playerAttackTarget(attacker, targetRef){
  const attackerIndex = player.field.indexOf(attacker);
  if(attackerIndex < 0){ attackMode=false; selectedAttacker=null; renderBattle(); return; }
  const defender = cpu.field[targetRef.index];
  if(!defender){ attackMode=false; selectedAttacker=null; renderBattle(); return; }
  const aAtk = attacker.atk + (attacker.tempBuff||0);
  const dAtk = defender.atk + (defender.tempBuff||0);
  if(aAtk > dAtk){
    cpu.grave.push({id:defender.id, name:defender.name}); cpu.field.splice(targetRef.index,1);
    logAction(`${attacker.name} が ${defender.name} を破壊`);
  } else if(aAtk < dAtk){
    player.grave.push({id:attacker.id, name:attacker.name}); const ai = player.field.indexOf(attacker); if(ai>=0) player.field.splice(ai,1);
    logAction(`${attacker.name} は ${defender.name} に敗れ破壊`);
  } else {
    cpu.grave.push({id:defender.id, name:defender.name}); player.grave.push({id:attacker.id, name:attacker.name});
    const ai2 = player.field.indexOf(attacker); if(ai2>=0) player.field.splice(ai2,1);
    cpu.field.splice(targetRef.index,1);
    logAction(`同値で ${attacker.name} と ${defender.name} を両方破壊`);
  }
  attacker.hasAttacked = true;
  attackMode=false; selectedAttacker=null;
  renderBattle(); checkWin();
}
function directAttack(attackerIndex){
  const attacker = player.field[attackerIndex];
  if(!attacker || !attacker.canAttack || attacker.hasAttacked){ alert("攻撃不可"); return; }
  if(cpu.field.length > 0){ alert("相手場にモンスターがいるため直接攻撃できません"); return; }
  const dmg = attacker.atk + (attacker.tempBuff||0);
  cpu.life -= dmg;
  attacker.hasAttacked = true;
  logAction(`${attacker.name} が直接攻撃で ${dmg} ダメージ`);
  renderBattle(); checkWin();
}

/* ---------------------------
   endTurn & cpu logic
----------------------------*/
function endTurn(){
  if(!gameActive) return;
  triggerEndPhaseEffects(true);
  playerTurn = false; attackMode=false; selectedAttacker=null; renderBattle();
  setTimeout(cpuTurnMain, 600);
}

function cpuTurnMain(){
  if(!gameActive) return;
  startTurn(cpu); draw(cpu);

  // CPUプレイロジック: 出せるカードはできるだけ出す（優先: monster>field>spell）
  let didSomething;
  do {
    didSomething = false;
    for(let i=0;i<cpu.hand.length;i++){
      const c = cpu.hand[i];
      const cost = getCardCostFor(c, cpu);
      if(c.type==="monster" && cost <= cpu.currMana){
        cpu.currMana -= cost;
        cpu.field.push({uid:c.uid, id:c.id, name:c.name, atk:c.atk, canAttack:false, hasAttacked:false, tempBuff:0, extraAttacks: (c.id==="speedgolem"?2:1), img:c.img});
        cpu.hand.splice(i,1); didSomething = true;
        if(c.id==="slime"){
          const idx = cpu.deck.findIndex(x=>x.id==="slime");
          if(idx>=0){ const cc = cpu.deck.splice(idx,1)[0]; const dat = ALL_CARDS.find(x=>x.id===cc.id); cpu.hand.push({uid:cc.uid,id:dat.id,name:dat.name,type:dat.type,cost:dat.cost||0,atk:dat.atk||0,desc:dat.desc,img:dat.img}); }
        }
        break;
      } else if(c.type==="field" && cost <= cpu.currMana){
        cpu.currMana -= cost; if(globalField) cpu.grave.push({id:globalField.id,name:globalField.name}); globalField = {id:c.id,name:c.name,desc:c.desc}; cpu.hand.splice(i,1); didSomething=true; break;
      } else if(c.type==="spell" && cost <= cpu.currMana){
        // use only useful spells
        if(c.id==="thunder" || c.id==="relic" || c.id==="heal"){
          cpu.currMana -= cost; resolveSpell(c,false); cpu.grave.push({id:c.id,name:c.name}); cpu.hand.splice(i,1); didSomething=true; break;
        }
      }
    }
  } while(didSomething);

  // CPU攻撃: 倒せる相手を優先。いなければランダム、相手場空なら直接攻撃
  cpu.field.forEach(m=>{ m.canAttack = true; m.hasAttacked = false; m.extraAttacksUsed = 0; });
  for(let i=0;i<cpu.field.length;i++){
    const attacker = cpu.field[i];
    if(!attacker.canAttack) continue;
    if(attacker.hasAttacked && (!attacker.extraAttacks || attacker.extraAttacksUsed >= attacker.extraAttacks-1)) continue;

    // 倒せる相手優先
    let targetIdx = -1;
    for(let j=0;j<player.field.length;j++){ if(attacker.atk >= player.field[j].atk){ targetIdx = j; break; } }
    if(targetIdx >= 0){
      const defender = player.field[targetIdx];
      if(attacker.atk > defender.atk){ player.grave.push({id:defender.id,name:defender.name}); player.field.splice(targetIdx,1); logAction(`CPU の ${attacker.name} が ${defender.name} を破壊`); }
      else if(attacker.atk < defender.atk){ cpu.grave.push({id:attacker.id,name:attacker.name}); cpu.field.splice(i,1); logAction(`CPU の ${attacker.name} は破壊された`); }
      else { player.grave.push({id:defender.id,name:defender.name}); cpu.grave.push({id:attacker.id,name:attacker.name}); player.field.splice(targetIdx,1); cpu.field.splice(i,1); logAction(`CPU の ${attacker.name} と ${defender.name} が同時破壊`); }
    } else {
      if(player.field.length > 0){
        const idx = Math.floor(Math.random()*player.field.length);
        const defender = player.field[idx];
        if(attacker.atk > defender.atk){ player.grave.push({id:defender.id,name:defender.name}); player.field.splice(idx,1); logAction(`CPU の ${attacker.name} が ${defender.name} を破壊`); }
        else if(attacker.atk < defender.atk){ cpu.grave.push({id:attacker.id,name:attacker.name}); cpu.field.splice(i,1); logAction(`CPU の ${attacker.name} は破壊された`); }
        else { player.grave.push({id:defender.id,name:defender.name}); cpu.grave.push({id:attacker.id,name:attacker.name}); player.field.splice(idx,1); cpu.field.splice(i,1); logAction(`CPU の ${attacker.name} と ${defender.name} が同時破壊`); }
      } else {
        player.life -= attacker.atk;
        logAction(`CPU の ${attacker.name} が直接攻撃で ${attacker.atk} ダメージ`);
      }
    }
    attacker.hasAttacked = true;
    attacker.extraAttacksUsed = (attacker.extraAttacksUsed||0) + 1;
    if(checkWin()) return;
  }

  triggerEndPhaseEffects(false);
  startTurn(player); draw(player);
  playerTurn = true;
  renderBattle();
}

/* ---------------------------
   end-phase effects
----------------------------*/
function triggerEndPhaseEffects(isPlayer){
  const me = isPlayer ? player : cpu;
  const opp = isPlayer ? cpu : player;
  const oppHasJuju = opp.field.some(x=>x.id==="jyujutsushi");

  me.field.slice().forEach(m=>{
    if(m.id==="kijin" && !oppHasJuju){
      const candidates = opp.field.filter(x=> x.atk <= m.atk);
      if(candidates.length>0){
        const idx = opp.field.indexOf(candidates[Math.floor(Math.random()*candidates.length)]);
        const removed = opp.field.splice(idx,1)[0];
        opp.grave.push({id:removed.id,name:removed.name});
        logAction(`${m.name} の効果で相手の ${removed.name} を墓地へ`);
      }
    }
    if(m.id==="necromancer" && !oppHasJuju){
      const monsIdx = me.grave.findIndex(g=> ALL_CARDS.find(c=>c.id===g.id).type === "monster");
      if(monsIdx >= 0 && me.field.length < 5){
        const g = me.grave.splice(monsIdx,1)[0];
        const data = ALL_CARDS.find(x=>x.id===g.id);
        me.field.push({uid:Math.random(), id:data.id, name:data.name, atk:data.atk, canAttack:false, hasAttacked:false, tempBuff:0, img:data.img});
        logAction(`${m.name} の効果で ${data.name} を蘇生`);
      }
    }
  });

  if(globalField){
    if(globalField.id==="happy"){ draw(player); draw(cpu); logAction("ハッピーマウンテンで両者1枚ドロー"); }
    if(globalField.id==="forest"){
      const candidates=[];
      if(player.grave.length>0) candidates.push(player);
      if(cpu.grave.length>0) candidates.push(cpu);
      if(candidates.length>0){
        const pick = candidates[Math.floor(Math.random()*candidates.length)];
        const idx = Math.floor(Math.random()*pick.grave.length);
        const g = pick.grave.splice(idx,1)[0];
        const data = ALL_CARDS.find(x=>x.id===g.id);
        pick.hand.push({uid:Math.random(), id:data.id, name:data.name, type:data.type, cost:data.cost||0, atk:data.atk||0, desc:data.desc, img:data.img});
        logAction("亡者の森で墓地からカードが手札に回復");
      }
    }
  }
  renderBattle();
}

/* ---------------------------
   win check, modal
----------------------------*/
function checkWin(){
  if(player.life <= 0){ showEndModal(false); return true; }
  if(cpu.life <= 0){ showEndModal(true); return true; }
  return false;
}
function showEndModal(playerWon){
  gameActive = false;
  const modal = document.getElementById("modal");
  const box = document.getElementById("modalBox");
  modal.style.display = "flex";
  if(playerWon === true){
    box.innerHTML = `<h3>あなたの勝利！</h3><div class="muted">CPU戦勝利ではパックは付与されません（仕様）。</div><div style="margin-top:12px"><button class="btn" onclick="rematch()">再戦</button> <button class="btn" onclick="closeModalAndReturn()">タイトルへ戻る</button></div>`;
  } else {
    box.innerHTML = `<h3>あなたの敗北...</h3><div style="margin-top:12px"><button class="btn" onclick="rematch()">再戦</button> <button class="btn" onclick="closeModalAndReturn()">タイトルへ戻る</button></div>`;
  }
}
function rematch(){ closeModal(); startCPUQuickMatch(); }
function closeModalAndReturn(){ closeModal(); document.getElementById("battleArea").style.display="none"; gameActive=false; }
function closeModal(){ document.getElementById("modal").style.display="none"; }

/* ---------------------------
   surrender
----------------------------*/
function surrender(){ if(!confirm("本当に降参しますか？")) return; logAction("あなたは降参しました"); showEndModal(false); }

/* ---------------------------
   logs / grave
----------------------------*/
function logAction(text){ actionLog.unshift(`${new Date().toLocaleTimeString()} - ${text}`); renderLog(); }
function renderLog(){ document.getElementById("actionLog").innerHTML = actionLog.join("<br>"); }
function clearLog(){ actionLog = []; renderLog(); }

function renderGraveArea(){
  if(!player) return;
  document.getElementById("graveArea").innerHTML = `<strong>あなたの墓地</strong><div>${player.grave.map(x=>x.name).join(", ") || "(空)"}</div><hr><strong>相手の墓地</strong><div>${cpu.grave.map(x=>x.name).join(", ") || "(空)"}</div>`;
}
function showFullGrave(){ if(!player) return; showModal(`<h3>墓地詳細</h3><div><strong>あなた:</strong><div>${player.grave.map(x=>x.name).join("<br>")||"(空)"}</div><hr><strong>相手:</strong><div>${cpu.grave.map(x=>x.name).join("<br>")||"(空)"}</div></div>`); }

/* ---------------------------
   helper: show modal
----------------------------*/
function showModal(html){ const modal = document.getElementById("modal"); const box = document.getElementById("modalBox"); box.innerHTML = html + `<div style="margin-top:12px"><button class="btn" onclick="closeModal()">閉じる</button></div>`; modal.style.display = "flex"; }
function closeModal(){ document.getElementById("modal").style.display = "none"; }

/* ---------------------------
   save/load username & decks
----------------------------*/
function saveUsername(){ const v = document.getElementById("usernameInput").value.trim(); if(!v){ alert("名前を入力してください"); return; } username = v; saveAll(); updateTop(); alert("保存しました: " + username); }

/* ---------------------------
   pack UI wrapper (公開ボタンは packCount を消費)
----------------------------*/
function openPackManual(){ if(packCount <= 0){ alert("パックがありません"); return; } packCount--; saveAll(); updateTop(); openPackInternal(false); }

/* ---------------------------
   init
----------------------------*/
document.addEventListener("DOMContentLoaded", ()=>{
  loadAll(); ensureInitial(); updateTop();
  renderCollection(); renderDeckArea(); renderSavedDecks(); renderCollectionList();
});

/* ===========================
   補助関数（重複防止）
===========================*/
function renderCollectionList(){ renderCollectionListImpl(); }
function renderCollectionListImpl(){
  const area = document.getElementById("collectionList"); area.innerHTML = "";
  ALL_CARDS.forEach(c=>{
    const owned = collection[c.id] || 0;
    const d = document.createElement("div"); d.className="card small";
    d.innerHTML = `<img src="${c.img}"><div><strong>${c.name}</strong></div><div class="muted">${c.type} / cost:${c.cost||0} atk:${c.atk||"-"}</div><div style="font-size:12px">${c.desc}</div><div>所持:${owned}</div>`;
    area.appendChild(d);
  });
}
</script>
</body>
</html>
